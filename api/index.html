<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Junjie (Jason) Zhu">
        <link rel="canonical" href="http://aegis.stanford.edu/api/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>API Documentation - AEGIS Documentation</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="../css/extra.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/django.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">AEGIS Documentation</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="..">Home</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../install/">Installation</a>
</li>
                                    
<li >
    <a href="../manual/">Basic Manual</a>
</li>
                                    
<li >
    <a href="../tutorial/">Video Tutorials</a>
</li>
                                    
<li class="active">
    <a href="./">API Documentation</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Jupyter Notebooks <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../notebooks/aegis_single_cell_example.html">Single Cell RNA-seq Application</a>
</li>
                                    
<li >
    <a href="../notebooks/aegis_benchmark_part1.html">Benchmark for Testing: Part 1</a>
</li>
                                    
<li >
    <a href="../notebooks/aegis_benchmark_part2.html">Benchmark for Testing: Part 2</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../tutorial/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../notebooks/aegis_single_cell_example.html">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#python-documentation">Python Documentation</a></li>
            <li><a href="#serverdagraphpy">server/dagraph.py</a></li>
        <li class="main "><a href="#javascript-documentation">Javascript Documentation</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="python-documentation">Python Documentation</h1>
<h3 id="serverdagraphpy">server/dagraph.py</h3>
<pre><code class="python">class BaseNode(object):
    &quot;&quot;&quot; Data structure associated with a basic node

    Attributes:
        id (int): the global node id
        cid (int): the context node id
        children (list of int): the list of child nodes in terms of global node ids
        parents (list of int): the list of parent nodes in terms of global node ids
        n_parents (int): the number of parent nodes
        n_children (int): the number of children nodes
        n_ancestors (int): the number of ancestral (recursive parent) nodes
        n_descendents (int): the number of descendent (recursive children) nodes
        root (bool): whether or not the node is a root
        leaf (bool): whether or not the node is a leaf

    &quot;&quot;&quot;

class Node(BaseNode):
    &quot;&quot;&quot; Graph layout node which inherits the BaseNode object.

    Attributes:
        name (str): the name annotation of the node, such as &quot;GO:....&quot;
        weight (int): the number of gene annotations
        depth (int): the longest distance from the roots
        height (int): the longest distance from the leaves
        root_distance (int):
        depth_order: int
        height_order: int
        flex: int
        flex_order: int
        queried: bool

    &quot;&quot;&quot;
    def get_position_info(self):
        &quot;&quot;&quot; Create a dictionary of depth, height and flex x,y coordinates

        Args:
            None

        Returns:
            dict: the dictionary with x,y, coordinates under different views

        &quot;&quot;&quot;

class Link(object):
    &quot;&quot;&quot; Data structure for a link

    Attributes:
        source (:obj:Node): the parent node
        target (:obj:Node): the child node

    &quot;&quot;&quot;

class DAGraph(object):
    &quot;&quot;&quot; Data structure for a directed cyclic graph

    Attributes:
        nodes: a list of Node objects
        links: a list of Link objects
        roots: a list of node ids
        leaves: a list of leaf ids
        name_index_map: a map from a node name to its index in the `nodes` list
    &quot;&quot;&quot;

    def filter_redundant_nodes(self, node_map=None, roots=None):
        &quot;&quot;&quot; Apply graph refinement to remove redundant nodes

        Args:
            node_map: a map of node ids to Node objects (optional)
            roots: a list of node ids to be the roots (optional)

        Returns:
            a map of node ids to Node objects keeping only non-redundant nodes

        &quot;&quot;&quot;

    def create_map_to_context_nodes(self, node_context):
        &quot;&quot;&quot; Create a dictionary for the context nodes given a set of nodes
            Node objects that can encode the information of the updated
            height, depth, parents and children in the particular context
            defined by the nodes under selection. Relationships between nodes
            are inferred from the original DAG.

        Args:
            note_context: a dict of node ids mapping to anything

        Returns:
            dict : a map from node ids to new Node objects in the new context
            list: a list of root nodes in the new context

        &quot;&quot;&quot;

    def update_intrinsic_levels(self, metric, node_map=None):
        &quot;&quot;&quot; Update the hight or depth attributes based on the optional context

        Args:
            metric: either &quot;height&quot; or &quot;depth&quot;
            node_map: a map from node ids to Node objects (optional)

        Returns:
            dict: a map from node ids to Node objects with updated attributes

        &quot;&quot;&quot;

    def find_nodes_in_context(self, node_type, node_context, node_map=None):
        &quot;&quot;&quot; Find either roots or leaves in a node context

        Args:
            node_type: either &quot;root&quot; of &quot;leaf&quot;
            node_context: a dict or set of node ids
            node_map: a map from node ids to Node Objects (optional)

        Returns:
            list: node ids of the roots or the leaves

        &quot;&quot;&quot;

    def find_neighbors(self,
                       node_index,
                       relation,
                       node_map = None,
                       restrict_set= None):
        &quot;&quot;&quot; Find the neighbors of a node within a context or restricted set

        Args:
            node_index: the node id
            relation: either &quot;parents&quot; or &quot;children&quot;
            node_map: a map from node ids to Node Objects (optional)
            restrict_set: a dict or set of node ids to restrict search

        Returns:
            a list of (restricted) neighboring node ids

        &quot;&quot;&quot;

    def relation_search(self,
                        node_indices,
                        relation,
                        measure = &quot;level&quot;,
                        node_map = None,
                        restrict_set = None):
        &quot;&quot;&quot; Perform restricted hierarchical search with a queue

        Args:
            node_indices : list of node ids as the anchor for the search
            relation: either &quot;parents&quot; or &quot;children&quot;
            measure: only &quot;level&quot; for now
            node_map: a map from node ids to Node Objects (optional)
            restrict_set: a dict or set of node ids to restrict search

        Returns:
            dict: related nodes ids (including the anchors) mapped to measure

        &quot;&quot;&quot;

    def create_node_grouping(self,
                             node_list,
                             context_map,
                             restrict_set=None):
        &quot;&quot;&quot; Given a list of node ids, group their descendants and
            ancestors into independent subgraphs for better layout.
            There are always some nodes that are in more than one groups
            so we want to partition the nodes optimally or greedily

        Args:
            node_list: list of node_ids
            context_map:  a map from node ids to Node Objects (optional)
            restrict_set: a dict or set of node ids to restrict search

        Returns:
            list: list of set of node ids indicating grouping

        &quot;&quot;&quot;

    def compute_focus_flex_level(self,
                                 focus_nodes,
                                 context_map,
                                 gap_break = 5000,
                                 block_merge = False):
        &quot;&quot;&quot; Compute the level of each node using the bubble float algorithm
            heuristic: larger gap_break yields fewer nodes per level

        Args:
            focus_nodes: a set (or list or dict) of node ids
            context_map: a map from node ids to Node Objects
            gap_break: the maximum node weight difference between two layers
            block_merge: (default as False for now)

        Returns:
            None (only updates the Node objects in the context map)

        &quot;&quot;&quot;

    def create_level_node_map(self, node_levels, node_indices=None):
        &quot;&quot;&quot; Create a map from level number to the node ids

        Args:
            node_levels: a dictionary of node_index to levels (like a context)
            node_list: a list of nodes to compute the level map for

        Returns:
            dict: (level) -&gt; [nidx_1, nidx_2, ...] (ordered list)

        &quot;&quot;&quot;

    def compute_node_order(self, node_indices, level_type, context_map):
        &quot;&quot;&quot; Given node ids and level type, compute its level specific position
            Uses the the hierarchical ordering heuristic

        Args:
            node_indices: a list/dict/set of node ids
            level_type: &quot;height&quot;, &quot;depth&quot; or &quot;flex&quot;
            context_map: a map from node ids to Node Objects with specified attr

        Returns:
            dict: a map from node ids to their order in the level

        &quot;&quot;&quot;

class OrderedContext():

        # index all the nodes in a given context cntx_d.
        # cntx_id is a dictionary mapping full context node id to the node
        self.sorted_nodes = None
        self.sorted_index_map = None
        # fixed_groups: nodes organized in a particular fixed grouping
        # retrieve the maximum number of levels
        self.fixed_level_nodes = None

    def boundary_histogram_search(self, level_breaks):
        &quot;&quot;&quot;
        For each level, determine the starting index in that level
        If the level breaks are [a, b, c], then the counts should be
        [|{x: x &gt;= a}|, |{x: a &gt; x &gt;= b}|, |{x: b &gt; x &gt;= c}|]

        NOTE: duplicate boundaries may occur, in this case, this could
        be due to the fact that there are nodes of the same size in the
        focus graph. This edge case should be handled before (and possibly
        after) this funciton is called

        Parameters
        ----------
        leve_breaks: obj: `list`
            A descending list of node weights dividers, e.g., [18529, 75, 1]

        Returns
        -------
        set
            dict of node indices mapped to their measure

        &quot;&quot;&quot;

    def generate_fixed_level_counts(self, lev_t):

    def bouyant_context_layout(self, focus_node_ids):

    def format_node_data(self, node):

    def output_lite_node_info(self):

    def output_plain_tested_graph(self):


class GOStat():
    def __init__(self):

    def set_test_attr_from_dict(self, in_dict):

    def get_test_attr_as_dict(self):

    def reverse_list_to_dict(self, in_list, do_sort = True):

    def setup_simulation_oneway(self, params):

    def get_simulation_gene_list(self):

    def get_node_meta_dict(self):

    def evaluate_rejections(self, rej_list, nonnull_type):

    def determine_non_null(self, gene_ids):

    def independent_fisher_tests(self, study_genes, verbose=False):

    def independent_binomial_tests(self, study_genes, alpha, verbose=False):

    def independent_global_tests(self, gene_pvalues, method=&quot;Simes&quot;):

    def generate_node_pvals_from_gene_pvals(self,
                                            genes,
                                            pvals,
                                            test=&quot;simes&quot;,
                                            cutoff=None,
                                            verbose=False):
        # the order of the genes should correspond to the p-values
        # these genes must be entrez ids to match the gene_go_map
        # returns a list of p-values that correspond to the node ordering
        # in the Ordered Context


    def convert_gene_from_to(self, source, target, gene_list):

    def output_ground_truth_info(self, output_graph=False):

class GODAGraph(DAGraph):

    def __init__(self,
                 cache_dir,
                 name=None,
                 sim_dir=None):
        DAGraph.__init__(self)
        # book-keeping attributes
        self.cache_dir = cache_dir
        self.sim_dir = sim_dir
        self.name = name
        self.go_fname =  None
        # ontology-specific attributes
        self.ontology = None
        self.species = None
        self.version = None
        self.root = None
        # gene-related attributes
        self.go_gene_map = {}
        self.gene_conversion_map = {}
        self.go_annotation = {}
        self.gene_go_map = {}
        # context and focus graph attributes
        self.context_graph = OrderedContext()
        self.context_params = {}
        self.focus_graph = None
        self.focus_params = {}
        # testing attributes
        self.gohelper = None
        self.main_statistician = GOStat()

    def restore_testing_configuration(self, job_id):

    def load_node_power_matrix(self, output_dir, test, multitest, nonnull_only=False):

    def output_node_power_matrix(self, job_id, test, multitest):

    def output_summary_stats(self, job_id, test_method, adjust_method):

    def generate_node_power_matrix(self,
                                   output_dir,
                                   test,
                                   multitest):

    def summarize_trial_result(self, dat_dir, reg_i, rep_i):
        # create summary date frame with fields including fields:
        # 1. testing_method
        # 2. adjustment_method
        # 3. nonnull_type
        # 3. emperical_fdr
        # 4. emperical_power
        # 5. num_rejections
        # ----------------------
        # 6. regime_id
        # 7. repetition_id
        # 8. trial_id
        # ----------------------

    def summarize_simulation_results(self, dat_dir):

    def generate_summary_files(self, data_dir):

    def launch_simulation_pipeline(self, job_id, cleanup=False):

    def generate_trial_node_stats(self,
                                  data_dir,
                                  trial_id):

    def generate_trial_gene_stats(self,
                                  data_dir,
                                  trial_id,
                                  simulation=True,
                                  save_xy=True):

    def load_full_test_summary(self, data_dir):

    def load_regime_test_summary(self, data_dir):

    def load_gene_pvals(self, data_dir, reg_i, rep_i):

    def load_test_result(self,
                         data_dir,
                         reg_i,
                         rep_i,
                         test,
                         eval_rej=True):

    def get_node_test_file_info(self,
                                rtype,
                                tmeth,
                                mode=&quot;Default&quot;,
                                mmeth=None,
                                alpha=None):

    def get_file_info(self, fd, mode=&quot;Default&quot;):

    def get_file_groups(self, key):

    def store_test_meta_data(self, data_dir, simulation=True):

    def output_initialization_data(self):

    def output_context_summary(self, slow_reachability=False):

    def output_non_null_go_terms(self, gene_symb_list):

    def save_result(self, data, fname):

    def load_result(self, fname):

    def sample_genes(self, n_genes, go_term, exclude=False, seedn=0):
        &quot;&quot;&quot;
            Sample gene sets based on GO term

            Sample genes that are inclusive or exclusive to a go term.

            Parameters
            ----------
            n_genes : int
                Number of genes to sample
            go_term : str
                The GO term to focus on
            exclude: bool, optional
                To exclude genes from this go-term (default: False: &quot;include&quot;)
            seedn: int, optional
                The random seed to sample the genes (default: 0)

            Returns
            -------
            None

        &quot;&quot;&quot;
    # maps supplied by gohelper
    def update_with_gene_annotations(self,
                                     propagate_to_parents=True,
                                     background_gene_set=None):

    def update_context_indices(self, context):

    def setup_context_graph(self,
                            rule,
                            target_node_list,
                            min_w=1,
                            max_w=30000,
                            refine_graph=False,
                            store_context=True):
        &quot;&quot;&quot;
        Create a context graph based on target nodes and rules

        Parameters
        ----------
        rule : obj: `str`
            Rule to build the context: &quot;waypoint&quot;, &quot;root&quot; or &quot;leaf&quot;
        target_node_list: obj: `list`
            A list of node names (GO:..) that will be the target by the rule.
        min_w: obj: `int`
            The minimum number of genes that each node should have
        max_w: obj: `int`
            The maximum number of genes that each node should have
        refine_graph: obj: `bool`
            Whether or not to remove redundent GO terms

        Returns
        -------
        set
            dict of node indices mapped to their measure

        &quot;&quot;&quot;

    def select_focus_nodes(self,
                           query_set,
                           context_map,
                           params):

    def create_node_group_order(self,
                                focus_node_level,
                                groups,
                                level_type,
                                context_map):

    def create_focus_layout(self,
                            query_set,
                            fnode_set,
                            context_map,
                            params):

    def setup_focus_graph(self,
                          query_go_ids,
                          ordered_context=None,
                          rule=&quot;waypoint&quot;,
                          max_descendents=10,
                          force_all_descendents=False,
                          gap_break=5000,
                          grouped=True,
                          ):


    def get_focus_graph_max_range(self, indexed_focus_nodes):

    def setup_full_dag(self,
                       ontology,
                       species,
                       version,
                       use_cache=True):
        &quot;&quot;&quot;
        Integrates annotaiton information to the GO DAG

        This steps includes reading the annotation files for a particular
        root DAG and a particular species, and creating the core structure
        for context and focus selection, as well as statistical testing.
        The parameters (root, species and etc.) were determined when the
        GODAGraph object is created.

        Parameters
        ----------
        use_cache : :obj:`bool`
            Whether or not to store/use a cached version of the DAG

        Returns
        -------
        dict
            a dictionary mapping from node indices to context Node objects

        &quot;&quot;&quot;

    def output_general_info(self):

    def output_context_info(self, c_graph):

    def prepare_focus_graph_output(self,
                                   query_set,
                                   node_set,
                                   index_map,
                                   context = None):

    def create_graph_from_root(self, is_a_only=False):

    def generate_random_pvalues(self):

    def get_example_gene_set(self, example_i):

    def get_example_params(self):

    def example_simulation(self, fixed_size=True, use_cache=False):

    def plot_full_result(self, data_dir):

</code></pre>

<h2>server/algorithms.py</h2>

<pre><code class="python">
def count_inverions(A):

def inverse_cumsum(z):

def bubble_float_algo(nodes,
                      node_weights,
                      node_depths,
                      node_parents,
                      node_order=None,
                      gap_break=3,
                      block_merge=False):
</code></pre>

<h1 id="javascript-documentation">Javascript Documentation</h1></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
