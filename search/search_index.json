{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! This is the documentation webpage for AEGIS (Augmented Exploration of the GO with Interactive Simulations). AEGIS is an open-source software with an interactive information-retrieval framework that enables an investigator to navigate through the entire Gene Ontology (GO) graph (with tens of thousands of nodes) and focus on fine-grained details without losing the context. It features interpretable visualization of GO terms reported from studies, flexible exploratory analysis of the GO DAG, as well as principled power analysis that is biologically grounded. Quick links Technical details in our bioRxiv paper Video tutorials of our visual concepts Source code in Python and Javascript Behind the Name According to Greek Mythology , Perseus used Athena\u2019s shield to look at Medusa's reflection without being petrified. This shield that empowered Perseus to defeat Medusa later became the AEGIS. To see the object of interest in a way that is manageable and informative, one cannot directly \u201clook at it,\u201d but appropriate visualization tools are needed. The modern concept of doing something \"under someone's aegis\" means doing something under the protection of a powerful, knowledgeable, or benevolent source. By combining visualization with the rich knowledge in the Gene Ontology, we hope to offer scientists a new tool to discover hidden patterns and uncover the gems in their data. Minerve remettant \u00e0 Pers\u00e9e son bouclier avec lequel il doit combattre La M\u00e9duse by Houasse Ren\u00e9 Antoine ( Image Source ) Getting Started Accompanied by our tutorials , there are two options to explore the visualization by AEGIS: the lite version and the full version. The lite version A light weight version of AEGIS is available as a web interface here . It includes the minimal interactive features with some examples for simple demonstrations. The lite version does not require installation and serves as an introduction to our visualization concepts. The full version The full version includes all features, including data upload and power analysis functions. This version is meant to be installed locally and include more customization and computationally intensive processes. The code is open source with api documentation so advanced pipelines can customize it to their needs. The Gene Ontology The GO is one of the most popular biological knowledge bases. It consists of two continuously evolving elements: (1) a collection of controlled biological terms with semantic hierarchical relationships and (2) annotations that link genes and gene products to specific terms. The GO can be represented as a graph where each node represents a GO term, and each directed link pointing from a parent to a child represents the semantic relationship with two terms. The child term can be related to the parent term via an \u201cis a\u201d, \u201cpart of\u201d or \u201cregulates\u201d relation. There are three root nodes: \u201cbiological process\u201d, \u201cmolecular function\u201d and \u201ccellular component\u201d, and each of their descendants are connected with directed edges in an acyclic fashion. Genes can be simultaneously annotated to different terms, and their annotations propagate upwards in the hierarchy, resulting in the gene sets in the nodes. For more detailed information about the GO, please visit the GO Consortium and the GO Handbook . Contact Us AEGIS is developed and maintained by Junjie (Jason) Zhu in the Sabatti Lab at Stanford University . Both Qian Zhao and Eugene Katsevich have also contributed to the development of this project. Feel free to contact jjzhu AT stanford DOT edu for feedback and quesitons. You are welcome to provide feedback via this questionnaire How to Cite Our manuscript is currently under review and instructions will be available soon. You can cite our bioRxiv paper .","title":"Home"},{"location":"#welcome","text":"This is the documentation webpage for AEGIS (Augmented Exploration of the GO with Interactive Simulations). AEGIS is an open-source software with an interactive information-retrieval framework that enables an investigator to navigate through the entire Gene Ontology (GO) graph (with tens of thousands of nodes) and focus on fine-grained details without losing the context. It features interpretable visualization of GO terms reported from studies, flexible exploratory analysis of the GO DAG, as well as principled power analysis that is biologically grounded.","title":"Welcome!"},{"location":"#quick-links","text":"Technical details in our bioRxiv paper Video tutorials of our visual concepts Source code in Python and Javascript","title":"Quick links"},{"location":"#behind-the-name","text":"According to Greek Mythology , Perseus used Athena\u2019s shield to look at Medusa's reflection without being petrified. This shield that empowered Perseus to defeat Medusa later became the AEGIS. To see the object of interest in a way that is manageable and informative, one cannot directly \u201clook at it,\u201d but appropriate visualization tools are needed. The modern concept of doing something \"under someone's aegis\" means doing something under the protection of a powerful, knowledgeable, or benevolent source. By combining visualization with the rich knowledge in the Gene Ontology, we hope to offer scientists a new tool to discover hidden patterns and uncover the gems in their data. Minerve remettant \u00e0 Pers\u00e9e son bouclier avec lequel il doit combattre La M\u00e9duse by Houasse Ren\u00e9 Antoine ( Image Source )","title":"Behind the Name"},{"location":"#getting-started","text":"Accompanied by our tutorials , there are two options to explore the visualization by AEGIS: the lite version and the full version.","title":"Getting Started"},{"location":"#the-lite-version","text":"A light weight version of AEGIS is available as a web interface here . It includes the minimal interactive features with some examples for simple demonstrations. The lite version does not require installation and serves as an introduction to our visualization concepts.","title":"The lite version"},{"location":"#the-full-version","text":"The full version includes all features, including data upload and power analysis functions. This version is meant to be installed locally and include more customization and computationally intensive processes. The code is open source with api documentation so advanced pipelines can customize it to their needs.","title":"The full version"},{"location":"#the-gene-ontology","text":"The GO is one of the most popular biological knowledge bases. It consists of two continuously evolving elements: (1) a collection of controlled biological terms with semantic hierarchical relationships and (2) annotations that link genes and gene products to specific terms. The GO can be represented as a graph where each node represents a GO term, and each directed link pointing from a parent to a child represents the semantic relationship with two terms. The child term can be related to the parent term via an \u201cis a\u201d, \u201cpart of\u201d or \u201cregulates\u201d relation. There are three root nodes: \u201cbiological process\u201d, \u201cmolecular function\u201d and \u201ccellular component\u201d, and each of their descendants are connected with directed edges in an acyclic fashion. Genes can be simultaneously annotated to different terms, and their annotations propagate upwards in the hierarchy, resulting in the gene sets in the nodes. For more detailed information about the GO, please visit the GO Consortium and the GO Handbook .","title":"The Gene Ontology"},{"location":"#contact-us","text":"AEGIS is developed and maintained by Junjie (Jason) Zhu in the Sabatti Lab at Stanford University . Both Qian Zhao and Eugene Katsevich have also contributed to the development of this project. Feel free to contact jjzhu AT stanford DOT edu for feedback and quesitons. You are welcome to provide feedback via this questionnaire","title":"Contact Us"},{"location":"#how-to-cite","text":"Our manuscript is currently under review and instructions will be available soon. You can cite our bioRxiv paper .","title":"How to Cite"},{"location":"api/","text":"Python Documentation server/dagraph.py class BaseNode ( object ): \"\"\" Data structure associated with a basic node Attributes: id (int): the global node id cid (int): the context node id children (list of int): the list of child nodes in terms of global node ids parents (list of int): the list of parent nodes in terms of global node ids n_parents (int): the number of parent nodes n_children (int): the number of children nodes n_ancestors (int): the number of ancestral (recursive parent) nodes n_descendents (int): the number of descendent (recursive children) nodes root (bool): whether or not the node is a root leaf (bool): whether or not the node is a leaf \"\"\" class Node ( BaseNode ): \"\"\" Graph layout node which inherits the BaseNode object. Attributes: name (str): the name annotation of the node, such as \"GO:....\" weight (int): the number of gene annotations depth (int): the longest distance from the roots height (int): the longest distance from the leaves root_distance (int): depth_order: int height_order: int flex: int flex_order: int queried: bool \"\"\" def get_position_info ( self ): \"\"\" Create a dictionary of depth, height and flex x,y coordinates Args: None Returns: dict: the dictionary with x,y, coordinates under different views \"\"\" class Link ( object ): \"\"\" Data structure for a link Attributes: source (:obj:Node): the parent node target (:obj:Node): the child node \"\"\" class DAGraph ( object ): \"\"\" Data structure for a directed cyclic graph Attributes: nodes: a list of Node objects links: a list of Link objects roots: a list of node ids leaves: a list of leaf ids name_index_map: a map from a node name to its index in the `nodes` list \"\"\" def filter_redundant_nodes ( self , node_map = None , roots = None ): \"\"\" Apply graph refinement to remove redundant nodes Args: node_map: a map of node ids to Node objects (optional) roots: a list of node ids to be the roots (optional) Returns: a map of node ids to Node objects keeping only non-redundant nodes \"\"\" def create_map_to_context_nodes ( self , node_context ): \"\"\" Create a dictionary for the context nodes given a set of nodes Node objects that can encode the information of the updated height, depth, parents and children in the particular context defined by the nodes under selection. Relationships between nodes are inferred from the original DAG. Args: note_context: a dict of node ids mapping to anything Returns: dict : a map from node ids to new Node objects in the new context list: a list of root nodes in the new context \"\"\" def update_intrinsic_levels ( self , metric , node_map = None ): \"\"\" Update the hight or depth attributes based on the optional context Args: metric: either \"height\" or \"depth\" node_map: a map from node ids to Node objects (optional) Returns: dict: a map from node ids to Node objects with updated attributes \"\"\" def find_nodes_in_context ( self , node_type , node_context , node_map = None ): \"\"\" Find either roots or leaves in a node context Args: node_type: either \"root\" of \"leaf\" node_context: a dict or set of node ids node_map: a map from node ids to Node Objects (optional) Returns: list: node ids of the roots or the leaves \"\"\" def find_neighbors ( self , node_index , relation , node_map = None , restrict_set = None ): \"\"\" Find the neighbors of a node within a context or restricted set Args: node_index: the node id relation: either \"parents\" or \"children\" node_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: a list of (restricted) neighboring node ids \"\"\" def relation_search ( self , node_indices , relation , measure = \"level\" , node_map = None , restrict_set = None ): \"\"\" Perform restricted hierarchical search with a queue Args: node_indices : list of node ids as the anchor for the search relation: either \"parents\" or \"children\" measure: only \"level\" for now node_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: dict: related nodes ids (including the anchors) mapped to measure \"\"\" def create_node_grouping ( self , node_list , context_map , restrict_set = None ): \"\"\" Given a list of node ids, group their descendants and ancestors into independent subgraphs for better layout. There are always some nodes that are in more than one groups so we want to partition the nodes optimally or greedily Args: node_list: list of node_ids context_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: list: list of set of node ids indicating grouping \"\"\" def compute_focus_flex_level ( self , focus_nodes , context_map , gap_break = 5000 , block_merge = False ): \"\"\" Compute the level of each node using the bubble float algorithm heuristic: larger gap_break yields fewer nodes per level Args: focus_nodes: a set (or list or dict) of node ids context_map: a map from node ids to Node Objects gap_break: the maximum node weight difference between two layers block_merge: (default as False for now) Returns: None (only updates the Node objects in the context map) \"\"\" def create_level_node_map ( self , node_levels , node_indices = None ): \"\"\" Create a map from level number to the node ids Args: node_levels: a dictionary of node_index to levels (like a context) node_list: a list of nodes to compute the level map for Returns: dict: (level) -> [nidx_1, nidx_2, ...] (ordered list) \"\"\" def compute_node_order ( self , node_indices , level_type , context_map ): \"\"\" Given node ids and level type, compute its level specific position Uses the the hierarchical ordering heuristic Args: node_indices: a list/dict/set of node ids level_type: \"height\", \"depth\" or \"flex\" context_map: a map from node ids to Node Objects with specified attr Returns: dict: a map from node ids to their order in the level \"\"\" class OrderedContext (): # index all the nodes in a given context cntx_d. # cntx_id is a dictionary mapping full context node id to the node sorted_nodes = None sorted_index_map = None # fixed_groups: nodes organized in a particular fixed grouping # retrieve the maximum number of levels fixed_level_nodes = None def boundary_histogram_search ( self , level_breaks ): \"\"\" For each level, determine the starting index in that level If the level breaks are [a, b, c], then the counts should be [|{x: x >= a}|, |{x: a > x >= b}|, |{x: b > x >= c}|] NOTE: duplicate boundaries may occur, in this case, this could be due to the fact that there are nodes of the same size in the focus graph. This edge case should be handled before (and possibly after) this funciton is called Parameters ---------- leve_breaks: obj: `list` A descending list of node weights dividers, e.g., [18529, 75, 1] Returns ------- set dict of node indices mapped to their measure \"\"\" def generate_fixed_level_counts ( self , lev_t ): def bouyant_context_layout ( self , focus_node_ids ): def format_node_data ( self , node ): def output_lite_node_info ( self ): def output_plain_tested_graph ( self ): class GOStat (): def __init__ ( self ): def set_test_attr_from_dict ( self , in_dict ): def get_test_attr_as_dict ( self ): def reverse_list_to_dict ( self , in_list , do_sort = True ): def setup_simulation_oneway ( self , params ): def get_simulation_gene_list ( self ): def get_node_meta_dict ( self ): def evaluate_rejections ( self , rej_list , nonnull_type ): def determine_non_null ( self , gene_ids ): def independent_fisher_tests ( self , study_genes , verbose = False ): def independent_binomial_tests ( self , study_genes , alpha , verbose = False ): def independent_global_tests ( self , gene_pvalues , method = \"Simes\" ): def generate_node_pvals_from_gene_pvals ( self , genes , pvals , test = \"simes\" , cutoff = None , verbose = False ): # the order of the genes should correspond to the p-values # these genes must be entrez ids to match the gene_go_map # returns a list of p-values that correspond to the node ordering # in the Ordered Context def convert_gene_from_to ( self , source , target , gene_list ): def output_ground_truth_info ( self , output_graph = False ): class GODAGraph ( DAGraph ): \"\"\" Data structure for the DAG for GO analysis Attributes: cache_dir: directory to store cache files sim_dir: directory to store simulation outputs name: name of the dag go_fname: directory to store the .pkl file for the object ontology: \"biological_process\",\"cellular_component\" or \"molecular_function\" species: \"human\" or \"mouse\" version: time stamp for version control root: the root of the entire ontolgy go_gene_map: map from GO id to a list of entrez gene ids gene_conversion_map: map from entrez gene id to gene symbol go_annotation: map from GO:id to the full GO name gene_go_map: map from entrez gene id to a list of GO ids context_graph: OrderedContext() object context_params: a data structure of context parameters main_statistician: GOStat() object used for statistical testing gohelper: GOHelper() object used for downloading and parsing the GO \"\"\" def setup_full_dag ( self , ontology , species , version , use_cache = True ): \"\"\" Integrates annotation information to the GO DAG This steps includes reading the annotation files for a particular root DAG and a particular species, and creating the core structure for context and focus selection. It also reads and writes the .pkl files used to load to populate the Object Args: ontology: \"biological_process\",\"cellular_component\" or \"molecular_function\" species: \"human\" or \"mouse\" version: time stamp for version control use_cache : whether or not to store/use a cached version of the DAG Returns ------- None \"\"\" def setup_context_graph ( self , rule , target_node_list , min_w = 1 , max_w = 30000 , refine_graph = False , store_context = True ): \"\"\" Create a context graph based on anchor nodes and rules Args: rule (str): rule to build the context: \"waypoint\", \"root\" or \"leaf\" target_node_list (list): a list of node names (GO:..) anchors min_w (int): the minimum number of genes that each node should have max_w (int):: the maximum number of genes that each node should have refine_graph (bool): whether or not to remove redundent GO terms Returns ------- OrderedContext: the Object representing the context dict: the parameters needed to specify the context \"\"\" def setup_focus_graph ( self , query_go_ids , ordered_context = None , rule = \"waypoint\" , max_descendents = 10 , force_all_descendents = False , gap_break = 5000 , grouped = True , ): \"\"\" Create a focus graph based on anchor nodes and rules Args: query_go_ids: a list of GO ids ordered_context: the context graph OrderedContext() rule: rule to build the context: \"waypoint\", \"root\" or \"leaf\" max_descendents: threshold for a node to be prolific force_all_descendents: whether or not to include all descendants gap_break: break parameter for the buoyant layout grouped: whether or not to segregate the terms into groups Returns: dict: the data structure of the graph needed for front-send display \"\"\" def restore_testing_configuration ( self , job_id ): \"\"\" Restores the testing configuration for the main_statistician, It also modifies the OrderedContext() based on the meta parameters Args: job_id: the id of the simulation job Returns: dict: all the parameters formatted for front-end rendering * \"\"\" def output_node_power_matrix ( self , job_id , test , multitest ): \"\"\" Output a matrix of node vs regime with node rejection rate Args: job_id: the id of the simulation job test: the method to generate node p-values multitest: the multiple correction method Returns: dict: a json-like matrix format \"\"\" def output_summary_stats ( self , job_id , test_method , adjust_method ): \"\"\" Output the summary statistics used for plotting Args: job_id: the id of the simulation job test_method: the method to generate node p-values adjust_method: the multiple correction method Returns: dict: a json-like matrix format for plotting \"\"\" def launch_simulation_pipeline ( self , job_id , cleanup = False ): def output_non_null_go_terms ( self , gene_symb_list ): def output_general_info ( self ): def output_context_info ( self , c_graph ): def plot_full_result ( self , data_dir ): server/algorithms.py def count_inverions ( A ): def inverse_cumsum ( z ): def bubble_float_algo ( nodes , node_weights , node_depths , node_parents , node_order = None , gap_break = 3 , block_merge = False ): Javascript Documentation static/js/all_configs.js static/js/go_interaction.js static/js/common_utils.js static/js/graph_utils.js static/js/bar_utils.js static/js/ss_manhattan.js","title":"API Documentation"},{"location":"api/#python-documentation","text":"","title":"Python Documentation"},{"location":"api/#serverdagraphpy","text":"class BaseNode ( object ): \"\"\" Data structure associated with a basic node Attributes: id (int): the global node id cid (int): the context node id children (list of int): the list of child nodes in terms of global node ids parents (list of int): the list of parent nodes in terms of global node ids n_parents (int): the number of parent nodes n_children (int): the number of children nodes n_ancestors (int): the number of ancestral (recursive parent) nodes n_descendents (int): the number of descendent (recursive children) nodes root (bool): whether or not the node is a root leaf (bool): whether or not the node is a leaf \"\"\" class Node ( BaseNode ): \"\"\" Graph layout node which inherits the BaseNode object. Attributes: name (str): the name annotation of the node, such as \"GO:....\" weight (int): the number of gene annotations depth (int): the longest distance from the roots height (int): the longest distance from the leaves root_distance (int): depth_order: int height_order: int flex: int flex_order: int queried: bool \"\"\" def get_position_info ( self ): \"\"\" Create a dictionary of depth, height and flex x,y coordinates Args: None Returns: dict: the dictionary with x,y, coordinates under different views \"\"\" class Link ( object ): \"\"\" Data structure for a link Attributes: source (:obj:Node): the parent node target (:obj:Node): the child node \"\"\" class DAGraph ( object ): \"\"\" Data structure for a directed cyclic graph Attributes: nodes: a list of Node objects links: a list of Link objects roots: a list of node ids leaves: a list of leaf ids name_index_map: a map from a node name to its index in the `nodes` list \"\"\" def filter_redundant_nodes ( self , node_map = None , roots = None ): \"\"\" Apply graph refinement to remove redundant nodes Args: node_map: a map of node ids to Node objects (optional) roots: a list of node ids to be the roots (optional) Returns: a map of node ids to Node objects keeping only non-redundant nodes \"\"\" def create_map_to_context_nodes ( self , node_context ): \"\"\" Create a dictionary for the context nodes given a set of nodes Node objects that can encode the information of the updated height, depth, parents and children in the particular context defined by the nodes under selection. Relationships between nodes are inferred from the original DAG. Args: note_context: a dict of node ids mapping to anything Returns: dict : a map from node ids to new Node objects in the new context list: a list of root nodes in the new context \"\"\" def update_intrinsic_levels ( self , metric , node_map = None ): \"\"\" Update the hight or depth attributes based on the optional context Args: metric: either \"height\" or \"depth\" node_map: a map from node ids to Node objects (optional) Returns: dict: a map from node ids to Node objects with updated attributes \"\"\" def find_nodes_in_context ( self , node_type , node_context , node_map = None ): \"\"\" Find either roots or leaves in a node context Args: node_type: either \"root\" of \"leaf\" node_context: a dict or set of node ids node_map: a map from node ids to Node Objects (optional) Returns: list: node ids of the roots or the leaves \"\"\" def find_neighbors ( self , node_index , relation , node_map = None , restrict_set = None ): \"\"\" Find the neighbors of a node within a context or restricted set Args: node_index: the node id relation: either \"parents\" or \"children\" node_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: a list of (restricted) neighboring node ids \"\"\" def relation_search ( self , node_indices , relation , measure = \"level\" , node_map = None , restrict_set = None ): \"\"\" Perform restricted hierarchical search with a queue Args: node_indices : list of node ids as the anchor for the search relation: either \"parents\" or \"children\" measure: only \"level\" for now node_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: dict: related nodes ids (including the anchors) mapped to measure \"\"\" def create_node_grouping ( self , node_list , context_map , restrict_set = None ): \"\"\" Given a list of node ids, group their descendants and ancestors into independent subgraphs for better layout. There are always some nodes that are in more than one groups so we want to partition the nodes optimally or greedily Args: node_list: list of node_ids context_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: list: list of set of node ids indicating grouping \"\"\" def compute_focus_flex_level ( self , focus_nodes , context_map , gap_break = 5000 , block_merge = False ): \"\"\" Compute the level of each node using the bubble float algorithm heuristic: larger gap_break yields fewer nodes per level Args: focus_nodes: a set (or list or dict) of node ids context_map: a map from node ids to Node Objects gap_break: the maximum node weight difference between two layers block_merge: (default as False for now) Returns: None (only updates the Node objects in the context map) \"\"\" def create_level_node_map ( self , node_levels , node_indices = None ): \"\"\" Create a map from level number to the node ids Args: node_levels: a dictionary of node_index to levels (like a context) node_list: a list of nodes to compute the level map for Returns: dict: (level) -> [nidx_1, nidx_2, ...] (ordered list) \"\"\" def compute_node_order ( self , node_indices , level_type , context_map ): \"\"\" Given node ids and level type, compute its level specific position Uses the the hierarchical ordering heuristic Args: node_indices: a list/dict/set of node ids level_type: \"height\", \"depth\" or \"flex\" context_map: a map from node ids to Node Objects with specified attr Returns: dict: a map from node ids to their order in the level \"\"\" class OrderedContext (): # index all the nodes in a given context cntx_d. # cntx_id is a dictionary mapping full context node id to the node sorted_nodes = None sorted_index_map = None # fixed_groups: nodes organized in a particular fixed grouping # retrieve the maximum number of levels fixed_level_nodes = None def boundary_histogram_search ( self , level_breaks ): \"\"\" For each level, determine the starting index in that level If the level breaks are [a, b, c], then the counts should be [|{x: x >= a}|, |{x: a > x >= b}|, |{x: b > x >= c}|] NOTE: duplicate boundaries may occur, in this case, this could be due to the fact that there are nodes of the same size in the focus graph. This edge case should be handled before (and possibly after) this funciton is called Parameters ---------- leve_breaks: obj: `list` A descending list of node weights dividers, e.g., [18529, 75, 1] Returns ------- set dict of node indices mapped to their measure \"\"\" def generate_fixed_level_counts ( self , lev_t ): def bouyant_context_layout ( self , focus_node_ids ): def format_node_data ( self , node ): def output_lite_node_info ( self ): def output_plain_tested_graph ( self ): class GOStat (): def __init__ ( self ): def set_test_attr_from_dict ( self , in_dict ): def get_test_attr_as_dict ( self ): def reverse_list_to_dict ( self , in_list , do_sort = True ): def setup_simulation_oneway ( self , params ): def get_simulation_gene_list ( self ): def get_node_meta_dict ( self ): def evaluate_rejections ( self , rej_list , nonnull_type ): def determine_non_null ( self , gene_ids ): def independent_fisher_tests ( self , study_genes , verbose = False ): def independent_binomial_tests ( self , study_genes , alpha , verbose = False ): def independent_global_tests ( self , gene_pvalues , method = \"Simes\" ): def generate_node_pvals_from_gene_pvals ( self , genes , pvals , test = \"simes\" , cutoff = None , verbose = False ): # the order of the genes should correspond to the p-values # these genes must be entrez ids to match the gene_go_map # returns a list of p-values that correspond to the node ordering # in the Ordered Context def convert_gene_from_to ( self , source , target , gene_list ): def output_ground_truth_info ( self , output_graph = False ): class GODAGraph ( DAGraph ): \"\"\" Data structure for the DAG for GO analysis Attributes: cache_dir: directory to store cache files sim_dir: directory to store simulation outputs name: name of the dag go_fname: directory to store the .pkl file for the object ontology: \"biological_process\",\"cellular_component\" or \"molecular_function\" species: \"human\" or \"mouse\" version: time stamp for version control root: the root of the entire ontolgy go_gene_map: map from GO id to a list of entrez gene ids gene_conversion_map: map from entrez gene id to gene symbol go_annotation: map from GO:id to the full GO name gene_go_map: map from entrez gene id to a list of GO ids context_graph: OrderedContext() object context_params: a data structure of context parameters main_statistician: GOStat() object used for statistical testing gohelper: GOHelper() object used for downloading and parsing the GO \"\"\" def setup_full_dag ( self , ontology , species , version , use_cache = True ): \"\"\" Integrates annotation information to the GO DAG This steps includes reading the annotation files for a particular root DAG and a particular species, and creating the core structure for context and focus selection. It also reads and writes the .pkl files used to load to populate the Object Args: ontology: \"biological_process\",\"cellular_component\" or \"molecular_function\" species: \"human\" or \"mouse\" version: time stamp for version control use_cache : whether or not to store/use a cached version of the DAG Returns ------- None \"\"\" def setup_context_graph ( self , rule , target_node_list , min_w = 1 , max_w = 30000 , refine_graph = False , store_context = True ): \"\"\" Create a context graph based on anchor nodes and rules Args: rule (str): rule to build the context: \"waypoint\", \"root\" or \"leaf\" target_node_list (list): a list of node names (GO:..) anchors min_w (int): the minimum number of genes that each node should have max_w (int):: the maximum number of genes that each node should have refine_graph (bool): whether or not to remove redundent GO terms Returns ------- OrderedContext: the Object representing the context dict: the parameters needed to specify the context \"\"\" def setup_focus_graph ( self , query_go_ids , ordered_context = None , rule = \"waypoint\" , max_descendents = 10 , force_all_descendents = False , gap_break = 5000 , grouped = True , ): \"\"\" Create a focus graph based on anchor nodes and rules Args: query_go_ids: a list of GO ids ordered_context: the context graph OrderedContext() rule: rule to build the context: \"waypoint\", \"root\" or \"leaf\" max_descendents: threshold for a node to be prolific force_all_descendents: whether or not to include all descendants gap_break: break parameter for the buoyant layout grouped: whether or not to segregate the terms into groups Returns: dict: the data structure of the graph needed for front-send display \"\"\" def restore_testing_configuration ( self , job_id ): \"\"\" Restores the testing configuration for the main_statistician, It also modifies the OrderedContext() based on the meta parameters Args: job_id: the id of the simulation job Returns: dict: all the parameters formatted for front-end rendering * \"\"\" def output_node_power_matrix ( self , job_id , test , multitest ): \"\"\" Output a matrix of node vs regime with node rejection rate Args: job_id: the id of the simulation job test: the method to generate node p-values multitest: the multiple correction method Returns: dict: a json-like matrix format \"\"\" def output_summary_stats ( self , job_id , test_method , adjust_method ): \"\"\" Output the summary statistics used for plotting Args: job_id: the id of the simulation job test_method: the method to generate node p-values adjust_method: the multiple correction method Returns: dict: a json-like matrix format for plotting \"\"\" def launch_simulation_pipeline ( self , job_id , cleanup = False ): def output_non_null_go_terms ( self , gene_symb_list ): def output_general_info ( self ): def output_context_info ( self , c_graph ): def plot_full_result ( self , data_dir ):","title":"server/dagraph.py"},{"location":"api/#serveralgorithmspy","text":"def count_inverions ( A ): def inverse_cumsum ( z ): def bubble_float_algo ( nodes , node_weights , node_depths , node_parents , node_order = None , gap_break = 3 , block_merge = False ):","title":"server/algorithms.py"},{"location":"api/#javascript-documentation","text":"","title":"Javascript Documentation"},{"location":"api/#staticjsall_configsjs","text":"","title":"static/js/all_configs.js"},{"location":"api/#staticjsgo_interactionjs","text":"","title":"static/js/go_interaction.js"},{"location":"api/#staticjscommon_utilsjs","text":"","title":"static/js/common_utils.js"},{"location":"api/#staticjsgraph_utilsjs","text":"","title":"static/js/graph_utils.js"},{"location":"api/#staticjsbar_utilsjs","text":"","title":"static/js/bar_utils.js"},{"location":"api/#staticjsss_manhattanjs","text":"","title":"static/js/ss_manhattan.js"},{"location":"install/","text":"AEGIS is an open-source software, and the back-end and front-end implementations in Python and Javscript are available under the MIT License. The following instructions are used to install the full version of AEGIs, which includes all of its functionalities including power calculation. Install Dependencies Prerequisites : Python3 (required), virtualenv or other package managements (recommended). The code is available on github, so you can directly clone the repository to your local: git clone git@github.com:junjiezhujason/aegis.git Installing of dependencies only requires one line: pip3 install -r requirements.txt AEGIS also requires specification of a folder: ${LOCALPATH} to store the cached files. This is mainly for version control and speed performance. For most of the analyses (excluding simulation outputs), the files will typically require no more than 250M of disk space. Note : If this is the first time that you are running AEGIS locally, Internet connection will be required to download data (or our cached files below) from the online databases. Download Caches (Optional) You can manually pre-propagate some local files in ${LOCALPATH} to reduce setup time. Once the cache is stored, most features of AEGIS can be performed locally without Internet connection for ontology or data download. Simply download the light cache files of (version-controlled) species/ontologies here and unpack to the directory ${LOCALPATH} , e.g., local_${VERSION}.tar.gz Make sure to expand the files in the ${LOCALPATH} so that the folder includes them in the following format: ${LOCALPATH}/local/godag_*.pkl Here is an example of the command line workflow: cd ${LOCALPATH} wget http://stanford.edu/~jjzhu/fileshare/aegis/local_20180710.tar.gz tar -xvzf local_20180710.tar.gz The local directory should have the following structure, for example: ${LOCALPATH}/local/godag-biological_process-human-20180719.pkl ${LOCALPATH}/local/godag-biological_process-mouse-20180719.pkl ${LOCALPATH}/local/godag-cellular_component-human-20180719.pkl ${LOCALPATH}/local/godag-cellular_component-mouse-20180719.pkl ${LOCALPATH}/local/godag-molecular_function-human-20180719.pkl ${LOCALPATH}/local/godag-molecular_function-mouse-20180719.pkl Here 20180719 represents the version number of the ontology paired with the annotation. It is highly useful for reproducing any results from the GO as well as AEGIS. Note : If you skip this step, the latest version of the GO and annotation files will be downloaded, and the total setup time will take longer. Launch the Local Server To launch the server, run: python3 main.py --port 5000 --folder ${LOCALPATH} Note : both the port number and the local path options are required. If this is your first time running AEGIS and you did not download our cached files, AEGIS will automatically download the latest gene and go annotations. This may take a while, and the following extra files will be automatically generated inside the local directory: ${LOCALPATH}/local/gene2go ${LOCALPATH}/local/go-basic.obo ${LOCALPATH}/local/geneid2sym_human.json ${LOCALPATH}/local/geneid2sym_mouse.json and later, the program will also generate the cached files ${LOCALPATH}/local/godag-*-*-*.pkl The version number will be based on the date the files are downloaded and when the .pkl file is created. By default, AEGIS will continue this version if the same ${LOCALPATH} is specified. To update the version, simply create a new local path to repeat the analysis above. Finally, open your local browser with http://localhost:5000/","title":"Installation"},{"location":"install/#install-dependencies","text":"Prerequisites : Python3 (required), virtualenv or other package managements (recommended). The code is available on github, so you can directly clone the repository to your local: git clone git@github.com:junjiezhujason/aegis.git Installing of dependencies only requires one line: pip3 install -r requirements.txt AEGIS also requires specification of a folder: ${LOCALPATH} to store the cached files. This is mainly for version control and speed performance. For most of the analyses (excluding simulation outputs), the files will typically require no more than 250M of disk space. Note : If this is the first time that you are running AEGIS locally, Internet connection will be required to download data (or our cached files below) from the online databases.","title":"Install Dependencies"},{"location":"install/#download-caches-optional","text":"You can manually pre-propagate some local files in ${LOCALPATH} to reduce setup time. Once the cache is stored, most features of AEGIS can be performed locally without Internet connection for ontology or data download. Simply download the light cache files of (version-controlled) species/ontologies here and unpack to the directory ${LOCALPATH} , e.g., local_${VERSION}.tar.gz Make sure to expand the files in the ${LOCALPATH} so that the folder includes them in the following format: ${LOCALPATH}/local/godag_*.pkl Here is an example of the command line workflow: cd ${LOCALPATH} wget http://stanford.edu/~jjzhu/fileshare/aegis/local_20180710.tar.gz tar -xvzf local_20180710.tar.gz The local directory should have the following structure, for example: ${LOCALPATH}/local/godag-biological_process-human-20180719.pkl ${LOCALPATH}/local/godag-biological_process-mouse-20180719.pkl ${LOCALPATH}/local/godag-cellular_component-human-20180719.pkl ${LOCALPATH}/local/godag-cellular_component-mouse-20180719.pkl ${LOCALPATH}/local/godag-molecular_function-human-20180719.pkl ${LOCALPATH}/local/godag-molecular_function-mouse-20180719.pkl Here 20180719 represents the version number of the ontology paired with the annotation. It is highly useful for reproducing any results from the GO as well as AEGIS. Note : If you skip this step, the latest version of the GO and annotation files will be downloaded, and the total setup time will take longer.","title":"Download Caches (Optional)"},{"location":"install/#launch-the-local-server","text":"To launch the server, run: python3 main.py --port 5000 --folder ${LOCALPATH} Note : both the port number and the local path options are required. If this is your first time running AEGIS and you did not download our cached files, AEGIS will automatically download the latest gene and go annotations. This may take a while, and the following extra files will be automatically generated inside the local directory: ${LOCALPATH}/local/gene2go ${LOCALPATH}/local/go-basic.obo ${LOCALPATH}/local/geneid2sym_human.json ${LOCALPATH}/local/geneid2sym_mouse.json and later, the program will also generate the cached files ${LOCALPATH}/local/godag-*-*-*.pkl The version number will be based on the date the files are downloaded and when the .pkl file is created. By default, AEGIS will continue this version if the same ${LOCALPATH} is specified. To update the version, simply create a new local path to repeat the analysis above. Finally, open your local browser with http://localhost:5000/","title":"Launch the Local Server"},{"location":"manual/","text":"Visualization Panel and Options Full and Lite Versions There are two options to explore the visualization by AEGIS: the lite version and the full version. The full version includes all features, including data upload and power analysis functions. A light weight version includes the minimal interactive features with some examples for simple demonstrations. Main Graphical Interface The following is the common graphical interface used in AEGIS. It consists several panels. Note In the lite version the context selection is disabled for performance reasons. You will need to install the full version to flexibly select the context. Further, the \"Download Options\" can vary based on which application of AEGIS a user chooses. Next, we will elaborate on what some of the terminologies mean and how to update the focus and context graphs using our options. Terminology and Concepts AEGIS also introduces some new concepts that facilitate interpretation and interactions. Focus graph, context graphs and their anchors AEGIS visualizes the GO graph based on the idea of a context and a focus graph. The following figure illustrates this concept, you can also find detailed explanation in our video demos . In a GO DAG, each node represents a GO term and each link represents a parent child relationship. The context graph (highlighted with red nodes above) is sub-DAG of the full DAG, based on context anchors (with pink borders). The focus graph (highlighted with blue nodes above) is a sub-DAG of the context graph. It is similarly selected based on focus anchors (with aqua borders). The context and focus anchors can be of three types: waypoint, root or leaf. If an anchor is a waypoint anchor, all of its ancestors and descendants will be included; if an anchor is a root anchor, only its descendants will be included; if an anchor is a leaf anchor, only its parents will be included. For our visualization (on the right), the context graph is represented via a silhouette view, only indicating the number of nodes in each level. The focus graph is represented as a bone fide graph with detailed links and nodes. Root-bound, leaf-bound and buoyant layouts The root-bound layout places each node at levels based on their longest distance to the root; the leaf-bound layout places them based on their longest distance to the leaves. Both of these options preserve a topological constraint where each parent node is higher than its children, and minimizes the number of levels in the DAG. The buoyant layout preserves not only the topological constraint, but also factors in the gene annotations, such that a node with fewer annotated genes is placed no higher than that with more genes. The buoyant layout is powered by our bubble-float algorithm. The leaf bound layout places each node at levels based on their longest distance to any of the leaves. Refinement of context If the \"refine\" option is selected for the context graph, then our internal algorithm will filter out nodes that have at least one child that shares the exact gene annotations. One advantage of this approach is to reduce the number of repetitive hypotheses during hypotheses testing and multiplicity correction. Prolific node and focus descendant threshold A GO term is a prolific node if the number of its children exceeds a threshold. We refer to the threshold as the \"focus descendant threshold\". For all the non-anchor nodes in the focus graph, we hide all the children (and possible descendants) if they are classified as prolific nodes. This feature aims to limit the display from being overcrowded. Note that the focus descendant threshold is adjustable. Outer focus anchors The outer focus anchors are the least redundant concepts among the selected focus anchors. In other words, if a focus anchor is not an outer focus anchor, then it must have at least one descendant that is a focus anchor - removing this node typically does not change the focus graph display. Clustered anchors For the focus graph, you have the option to group nodes based on the focus anchors such that it is easier to see the grouping structure among the nodes. The grouping is based on our customized topological sorting algorithm. Gap break For the buoyant layout specifically, the gap break is the maximum tolerance for the number of annotations between two consecutive nodes in the same level. It is recommended to use a larger gap break when there are fewer nodes, and smaller when there are more nodes. Binder plot for focus graph For the buoyant layout specifically, the binder plot constructs a linear representation of the nodes for the focus graph. The edges follow the Sugiyama-style graph drawing rules. Navigation Features A user can specify the focus and context graph to visualize within the \u201cfocus-and-context navigation\u201d tab. He/she can set parameters to modify the graph display (see \u201cfurther visualization adjustment\u201d), and interactively explore the GO DAG. Select Ontology Select ontology in drop-down menus in \u201cGeneral Options\u201d tab. AEGIS currently incorporates human and mouse ontology of biological process, cellular components, and molecular function. All relationships (e.g., \u201cis a\u201d, \u201cpart of\u201d, \u201chas part\u201d, or \u201cregulates\u201d) for the GO terms were used for the cellular component ontology, but only \u201cis a\u201d relationships were kept for the biological process ontology. Select Context and Focus Anchors To add a context anchor, type the GO term name (e.g. biological_process) or GO ID (e.g. GO: 0008150) into the search box next to \u201cContext Anchors\u201d tab. GO term names can be autocompleted. After selecting context anchors and context options, click refresh button to update context graph. There are three ways to add focus anchors in AEGIS: (1) type in GO term name or GO ID into the search box next to \u201cFocus Anchors\u201d tab (2) Double click a node in focus graph (3) Double click leveled \u201c+\u201d sign next to context graph. Context Graph Options The context anchors can be either waypoint anchors or root anchors. If the context anchors are waypoint anchors, the context graph includes all their descendents and ancestors. If they are root anchors, the context graph will include only their descendents (see \u201cvisualization concept\u201d). Select context anchor types in \u201canchor type\u201d drop down menu. The context graph can be filtered to include only GO terms whose node sizes fall in a particular range. Specify a range of node sizes in the \u201cnode size\u201d tab, click refresh button, the context graph will only include GO terms that are within this range. The context graph can be refined by clicking the refine button. If the user selects the refined context graph, all nodes that shares the same gene sets as their children will be removed, their edges will be redirected to nodes that inherits their gene sets. The focus anchors can be either waypoint anchors or leaf anchors. If the focus anchors are waypoint anchors, the focus graph includes all their descendents and ancestors. If they are leaf anchors, the focus graph will include only their parents. (see \u201cvisualization concept\u201d, \u201ccontext graph options\u201d). Select anchor type in corresponding drop-down menu. Set \u201cMaximum anchor\u201d to adjust maximum number of focus anchors that can be included in the focus graph. If current number of focus anchors is 4 and maximum anchor is set to be 4, adding another focus anchor will force the first focus anchor to be removed. Layout Options After selecting anchors, the user can choose graphical layout for the focus graph in the layout option drop-down menu. (see \u201cvisualization concept: buoyant layout\u201d) Interaction on the Focus Graph Figure above shows the initial graph display from AEGIS. On the left is the focus graph, nodes are placed at levels according to specified layout option (see \u201clayout option\u201d). Focus anchors are circled in aqua. Level node counts are shown at left the of focus graph. On the right is the context graph which is a bar chart of level node counts in the context graph. Hover mouse over a node to view the GO term information in the information board above. It also highlights relatives of the node, parents and children in dark red and others in red. Drag and drop a node to adjust its position. Double click a node to add it to focus anchors. If the node is a prolific node [visualization concept], double clicking will also display its children. Double click leveled \u201c+\u201d sign next to the context graph draws a random node in the context graph to be focus anchor. Gene Set Selection In addition to exploring the GO DAG, a user can use focus and context visualization in AEGIS to identify gene sets that might be usefully for applications such as differential gene expression analysis and single cell benchmarking. One main application of this function is for our built-in power analysis workflow . Select gene sets in the gene selection box [need a figure here], selected genes can be easily exported, or used as input signal genes for subsequent power simulation. This section is adapted from video demo, where you can find more examples. Searching for Genes A user can directly search for the gene symbol (or ensembl ID) in the \"Gene Selection\" input box. Gene names can be auto-completed. If you have little knowledge about gene names, the user can rely on the GO terms to select sets. They can select a number of GO terms by typing their names in the \u201cGO selection\u201d box to select GO terms. In this example, the GO term of interest \u201cadult heart development\u201d. To select \u201cadult heart development\u201d, type GO term name (\u201cadult heart development\u201d), or GO ID (\u201cGO: 0007512\u201d) into the search box. There is also auto-complete for the GO term name. Next, you can use the options below to randomly sample a number or a proportion of genes annotated with this GO term. Clearing and Copying A user can clear selected GO terms or selected genes individually or all at once. Click cross sign next to gene selection box to clear all terms. Click cross sign next to individual term to clear individual term. Click the clipboard sign to copy selected GO terms / genes to clipboard. Real-time update of self-contained and competitive nulls For power analysis specifically, once a user specify differentially expressed genes, they can highlight self-contained and competitive non-null terms within the current context graph in \u201chighlight\u201d options. Specifically, a GO term is a self-contained null if none of the genes annotated to it is differentially expressed. It is a competitive null if proportion of differentially expressed genes is less than that of the entire genome. For instance, the root node, \u201canimal organ development\u201d is a self-contained non-null, but it is not a competitive non-null. GO Term Data Input As a convenient way to specify context or focus anchors, a user can upload GO terms in the \u201cData upload\u201d section. The user can upload either focus or context anchors or both. When only focus anchors are specified, the context anchors will be initialized as the ontology roots. When only context anchors are specified, the focus anchors will be randomly initialized. When both are specified, only valid focus anchors within the specified context graph will be used. Note Currently, this data input functionality is only supported locally in the full version of AEGIS (which requires a simple installation ), and not in the lite version on the web server. To upload a GO term file, click \u201cData Upload\u201d to expand data upload box. Click \u201cChoose File\u201d button to upload GO terms. The required format is a .txt or .csv file, with one GO ID (e.g., GO: 0008150) per line. An example file that can be found at \u201caegis/data/great_srf_example.txt\u201d, which is uploaded as context anchors here. After file selection, click on refresh button, a green arrow appears if GO term file has been uploaded successfully. After uploading GO terms, the user need to choose the ontology and species in in \u201cGeneral Options\u201d panel. For this example, \u201chuman cellular component\u201d ontology is selected. Click refresh button after selecting desired ontology, a green arrow should appear if ontology is specified correctly. All the uploaded GO terms will appear in the box below. Otherwise, error message \u201cNone of the context anchors were identified in the current ontology. Perhaps the wrong ontology was selected\u201d will appear. Click \u201cContinue Navigation\u201d button to expand focus and context graphs. If no data is uploaded, click \u201cfocus-and-context anchor navigation\u201d to start GO exploration. Power Analysis and Simulation A user can perform power simulation for potential study design in the full version of AEGIS. Detailed explanation of power analysis workflow can be found in Section 5.1 in our manuscript. Here is an over view of the system. To enter the simulation and power analysis workflow, go to \u201cPower analysis setup\u201d tab within the main panel. Note Currently, this power analysis functionality is only supported locally in the full version of AEGIS (which requires a simple installation ), and not in the lite version on the web server. Selecting the Testing Context First, the user needs to select the testing context. The number of nodes to test is conveniently defined by the context graph. Thus, we also recommend a user to turn on the option to refine the graph to remove redundant identical tests. By default, the context is the entire ontology with refined nodes. Selecting Differentially Expressed Genes Core to the simulation is to select gene sets. A user needs to select truly differentially expressed genes \\{g_1, \u2026 ,g_m\\} \\{g_1, \u2026 ,g_m\\} (see Gene Set Selection ). Once a user selects truly differentially expressed genes, AEGIS generates gene expression data X X for case and control samples from the following multivariate normal model: $$ X \\sim \\mathcal{N}(0, I) $$ if X X is a control sample, and $$ X \\sim \\mathcal{N}(\\mu, I) $$ if X X is a case sample. Here \\mu \\mu corresponds to a vector which is equal to \\beta_{effect} \\beta_{effect} at the selected differentially expressed genes \\{g_1, \u2026 ,g_m\\} \\{g_1, \u2026 ,g_m\\} and 0 otherwise. Note The dimension of X X is the number of samples times the number of genes. The number of samples is a user-specified quantity, and the number of genes is determined based on the testing context: only genes annotated to the root nodes of the context graph are used. Specifying Simulation Parameters Beyond the gene set, many parameters can be selected. To set simulation parameters, click \u201cSimulation Parameters\u201d to expand simulation options. Use \u201cGene effect size/signal strength\u201d to set \\beta_{effect} \\beta_{effect} . Use \u201cMinimum of samples per case / control\u201d, \u201cMaximum of samples per case / control\u201d and \u201cNumber of linearly spaced sample size regimes\u201d to set number of case and control samples. For instance, if \u201cmin samples\u201d is 10, \u201cmax samples\u201d is 50, and \u201cnum linearly spaced samples\u201d is 10, then sample sizes {10, 20, 30, 40, 50 will be used in the simulation. A user can repeat simulation multiple times for each sample size, default value of \u201cNumber of repetitions per regime\u201d is 10 per sample size. A user can further use \u201cMultiple testing adjustment procedure\u201d to select Bonferroni / BH method to adjust for multiple hypothesis testing. He/she can set desired FDR level in \u201cGO term false discovery rate level\u201d. Launching the Simulation Finally, to launch the simulation, you will generate a unique job ID. Make sure to store this job ID as it will be used for retrieving the finalized output. Retrieving Simulation Results Once the simulation is complete, a user can use our interface to visualize the summary statistics and out customized renderings. The simulation-specific job ID is required to retrieve these results. Successfully loaded simulations should render the context graph that was used for testing, with focus nodes anchored on the (self-contained) non-null GO terms. Following the graph, the next panel on \"Power Analysis Result\" displays all the parameters used for the simulation and the summary statistics including false discovery rate (FDR), power and number of rejected GO terms. As one of our highlighted features, you can also visualize the node-specific power of nodes specified in the focus graph via binder plots by clicking \"View\" next to the \"Binder Plot Summary of the Focus Graph\". Again, this can be adjusted in the previous panel \"Reference Graph for Testing\".","title":"Web Interface Manual"},{"location":"manual/#visualization-panel-and-options","text":"","title":"Visualization Panel and Options"},{"location":"manual/#full-and-lite-versions","text":"There are two options to explore the visualization by AEGIS: the lite version and the full version. The full version includes all features, including data upload and power analysis functions. A light weight version includes the minimal interactive features with some examples for simple demonstrations.","title":"Full and Lite Versions"},{"location":"manual/#main-graphical-interface","text":"The following is the common graphical interface used in AEGIS. It consists several panels. Note In the lite version the context selection is disabled for performance reasons. You will need to install the full version to flexibly select the context. Further, the \"Download Options\" can vary based on which application of AEGIS a user chooses. Next, we will elaborate on what some of the terminologies mean and how to update the focus and context graphs using our options.","title":"Main Graphical Interface"},{"location":"manual/#terminology-and-concepts","text":"AEGIS also introduces some new concepts that facilitate interpretation and interactions.","title":"Terminology and Concepts"},{"location":"manual/#focus-graph-context-graphs-and-their-anchors","text":"AEGIS visualizes the GO graph based on the idea of a context and a focus graph. The following figure illustrates this concept, you can also find detailed explanation in our video demos . In a GO DAG, each node represents a GO term and each link represents a parent child relationship. The context graph (highlighted with red nodes above) is sub-DAG of the full DAG, based on context anchors (with pink borders). The focus graph (highlighted with blue nodes above) is a sub-DAG of the context graph. It is similarly selected based on focus anchors (with aqua borders). The context and focus anchors can be of three types: waypoint, root or leaf. If an anchor is a waypoint anchor, all of its ancestors and descendants will be included; if an anchor is a root anchor, only its descendants will be included; if an anchor is a leaf anchor, only its parents will be included. For our visualization (on the right), the context graph is represented via a silhouette view, only indicating the number of nodes in each level. The focus graph is represented as a bone fide graph with detailed links and nodes.","title":"Focus graph, context graphs and their anchors"},{"location":"manual/#root-bound-leaf-bound-and-buoyant-layouts","text":"The root-bound layout places each node at levels based on their longest distance to the root; the leaf-bound layout places them based on their longest distance to the leaves. Both of these options preserve a topological constraint where each parent node is higher than its children, and minimizes the number of levels in the DAG. The buoyant layout preserves not only the topological constraint, but also factors in the gene annotations, such that a node with fewer annotated genes is placed no higher than that with more genes. The buoyant layout is powered by our bubble-float algorithm. The leaf bound layout places each node at levels based on their longest distance to any of the leaves.","title":"Root-bound, leaf-bound and buoyant layouts"},{"location":"manual/#refinement-of-context","text":"If the \"refine\" option is selected for the context graph, then our internal algorithm will filter out nodes that have at least one child that shares the exact gene annotations. One advantage of this approach is to reduce the number of repetitive hypotheses during hypotheses testing and multiplicity correction.","title":"Refinement of context"},{"location":"manual/#prolific-node-and-focus-descendant-threshold","text":"A GO term is a prolific node if the number of its children exceeds a threshold. We refer to the threshold as the \"focus descendant threshold\". For all the non-anchor nodes in the focus graph, we hide all the children (and possible descendants) if they are classified as prolific nodes. This feature aims to limit the display from being overcrowded. Note that the focus descendant threshold is adjustable.","title":"Prolific node and focus descendant threshold"},{"location":"manual/#outer-focus-anchors","text":"The outer focus anchors are the least redundant concepts among the selected focus anchors. In other words, if a focus anchor is not an outer focus anchor, then it must have at least one descendant that is a focus anchor - removing this node typically does not change the focus graph display.","title":"Outer focus anchors"},{"location":"manual/#clustered-anchors","text":"For the focus graph, you have the option to group nodes based on the focus anchors such that it is easier to see the grouping structure among the nodes. The grouping is based on our customized topological sorting algorithm.","title":"Clustered anchors"},{"location":"manual/#gap-break","text":"For the buoyant layout specifically, the gap break is the maximum tolerance for the number of annotations between two consecutive nodes in the same level. It is recommended to use a larger gap break when there are fewer nodes, and smaller when there are more nodes.","title":"Gap break"},{"location":"manual/#binder-plot-for-focus-graph","text":"For the buoyant layout specifically, the binder plot constructs a linear representation of the nodes for the focus graph. The edges follow the Sugiyama-style graph drawing rules.","title":"Binder plot for focus graph"},{"location":"manual/#navigation-features","text":"A user can specify the focus and context graph to visualize within the \u201cfocus-and-context navigation\u201d tab. He/she can set parameters to modify the graph display (see \u201cfurther visualization adjustment\u201d), and interactively explore the GO DAG.","title":"Navigation Features"},{"location":"manual/#select-ontology","text":"Select ontology in drop-down menus in \u201cGeneral Options\u201d tab. AEGIS currently incorporates human and mouse ontology of biological process, cellular components, and molecular function. All relationships (e.g., \u201cis a\u201d, \u201cpart of\u201d, \u201chas part\u201d, or \u201cregulates\u201d) for the GO terms were used for the cellular component ontology, but only \u201cis a\u201d relationships were kept for the biological process ontology.","title":"Select Ontology"},{"location":"manual/#select-context-and-focus-anchors","text":"To add a context anchor, type the GO term name (e.g. biological_process) or GO ID (e.g. GO: 0008150) into the search box next to \u201cContext Anchors\u201d tab. GO term names can be autocompleted. After selecting context anchors and context options, click refresh button to update context graph. There are three ways to add focus anchors in AEGIS: (1) type in GO term name or GO ID into the search box next to \u201cFocus Anchors\u201d tab (2) Double click a node in focus graph (3) Double click leveled \u201c+\u201d sign next to context graph.","title":"Select Context and Focus Anchors"},{"location":"manual/#context-graph-options","text":"The context anchors can be either waypoint anchors or root anchors. If the context anchors are waypoint anchors, the context graph includes all their descendents and ancestors. If they are root anchors, the context graph will include only their descendents (see \u201cvisualization concept\u201d). Select context anchor types in \u201canchor type\u201d drop down menu. The context graph can be filtered to include only GO terms whose node sizes fall in a particular range. Specify a range of node sizes in the \u201cnode size\u201d tab, click refresh button, the context graph will only include GO terms that are within this range. The context graph can be refined by clicking the refine button. If the user selects the refined context graph, all nodes that shares the same gene sets as their children will be removed, their edges will be redirected to nodes that inherits their gene sets. The focus anchors can be either waypoint anchors or leaf anchors. If the focus anchors are waypoint anchors, the focus graph includes all their descendents and ancestors. If they are leaf anchors, the focus graph will include only their parents. (see \u201cvisualization concept\u201d, \u201ccontext graph options\u201d). Select anchor type in corresponding drop-down menu. Set \u201cMaximum anchor\u201d to adjust maximum number of focus anchors that can be included in the focus graph. If current number of focus anchors is 4 and maximum anchor is set to be 4, adding another focus anchor will force the first focus anchor to be removed.","title":"Context Graph Options"},{"location":"manual/#layout-options","text":"After selecting anchors, the user can choose graphical layout for the focus graph in the layout option drop-down menu. (see \u201cvisualization concept: buoyant layout\u201d)","title":"Layout Options"},{"location":"manual/#interaction-on-the-focus-graph","text":"Figure above shows the initial graph display from AEGIS. On the left is the focus graph, nodes are placed at levels according to specified layout option (see \u201clayout option\u201d). Focus anchors are circled in aqua. Level node counts are shown at left the of focus graph. On the right is the context graph which is a bar chart of level node counts in the context graph. Hover mouse over a node to view the GO term information in the information board above. It also highlights relatives of the node, parents and children in dark red and others in red. Drag and drop a node to adjust its position. Double click a node to add it to focus anchors. If the node is a prolific node [visualization concept], double clicking will also display its children. Double click leveled \u201c+\u201d sign next to the context graph draws a random node in the context graph to be focus anchor.","title":"Interaction on the Focus Graph"},{"location":"manual/#gene-set-selection","text":"In addition to exploring the GO DAG, a user can use focus and context visualization in AEGIS to identify gene sets that might be usefully for applications such as differential gene expression analysis and single cell benchmarking. One main application of this function is for our built-in power analysis workflow . Select gene sets in the gene selection box [need a figure here], selected genes can be easily exported, or used as input signal genes for subsequent power simulation. This section is adapted from video demo, where you can find more examples.","title":"Gene Set Selection"},{"location":"manual/#searching-for-genes","text":"A user can directly search for the gene symbol (or ensembl ID) in the \"Gene Selection\" input box. Gene names can be auto-completed. If you have little knowledge about gene names, the user can rely on the GO terms to select sets. They can select a number of GO terms by typing their names in the \u201cGO selection\u201d box to select GO terms. In this example, the GO term of interest \u201cadult heart development\u201d. To select \u201cadult heart development\u201d, type GO term name (\u201cadult heart development\u201d), or GO ID (\u201cGO: 0007512\u201d) into the search box. There is also auto-complete for the GO term name. Next, you can use the options below to randomly sample a number or a proportion of genes annotated with this GO term.","title":"Searching for Genes"},{"location":"manual/#clearing-and-copying","text":"A user can clear selected GO terms or selected genes individually or all at once. Click cross sign next to gene selection box to clear all terms. Click cross sign next to individual term to clear individual term. Click the clipboard sign to copy selected GO terms / genes to clipboard.","title":"Clearing and Copying"},{"location":"manual/#real-time-update-of-self-contained-and-competitive-nulls","text":"For power analysis specifically, once a user specify differentially expressed genes, they can highlight self-contained and competitive non-null terms within the current context graph in \u201chighlight\u201d options. Specifically, a GO term is a self-contained null if none of the genes annotated to it is differentially expressed. It is a competitive null if proportion of differentially expressed genes is less than that of the entire genome. For instance, the root node, \u201canimal organ development\u201d is a self-contained non-null, but it is not a competitive non-null.","title":"Real-time update of self-contained and competitive nulls"},{"location":"manual/#go-term-data-input","text":"As a convenient way to specify context or focus anchors, a user can upload GO terms in the \u201cData upload\u201d section. The user can upload either focus or context anchors or both. When only focus anchors are specified, the context anchors will be initialized as the ontology roots. When only context anchors are specified, the focus anchors will be randomly initialized. When both are specified, only valid focus anchors within the specified context graph will be used. Note Currently, this data input functionality is only supported locally in the full version of AEGIS (which requires a simple installation ), and not in the lite version on the web server. To upload a GO term file, click \u201cData Upload\u201d to expand data upload box. Click \u201cChoose File\u201d button to upload GO terms. The required format is a .txt or .csv file, with one GO ID (e.g., GO: 0008150) per line. An example file that can be found at \u201caegis/data/great_srf_example.txt\u201d, which is uploaded as context anchors here. After file selection, click on refresh button, a green arrow appears if GO term file has been uploaded successfully. After uploading GO terms, the user need to choose the ontology and species in in \u201cGeneral Options\u201d panel. For this example, \u201chuman cellular component\u201d ontology is selected. Click refresh button after selecting desired ontology, a green arrow should appear if ontology is specified correctly. All the uploaded GO terms will appear in the box below. Otherwise, error message \u201cNone of the context anchors were identified in the current ontology. Perhaps the wrong ontology was selected\u201d will appear. Click \u201cContinue Navigation\u201d button to expand focus and context graphs. If no data is uploaded, click \u201cfocus-and-context anchor navigation\u201d to start GO exploration.","title":"GO Term Data Input"},{"location":"manual/#power-analysis-and-simulation","text":"A user can perform power simulation for potential study design in the full version of AEGIS. Detailed explanation of power analysis workflow can be found in Section 5.1 in our manuscript. Here is an over view of the system. To enter the simulation and power analysis workflow, go to \u201cPower analysis setup\u201d tab within the main panel. Note Currently, this power analysis functionality is only supported locally in the full version of AEGIS (which requires a simple installation ), and not in the lite version on the web server.","title":"Power Analysis and Simulation"},{"location":"manual/#selecting-the-testing-context","text":"First, the user needs to select the testing context. The number of nodes to test is conveniently defined by the context graph. Thus, we also recommend a user to turn on the option to refine the graph to remove redundant identical tests. By default, the context is the entire ontology with refined nodes.","title":"Selecting the Testing Context"},{"location":"manual/#selecting-differentially-expressed-genes","text":"Core to the simulation is to select gene sets. A user needs to select truly differentially expressed genes \\{g_1, \u2026 ,g_m\\} \\{g_1, \u2026 ,g_m\\} (see Gene Set Selection ). Once a user selects truly differentially expressed genes, AEGIS generates gene expression data X X for case and control samples from the following multivariate normal model: $$ X \\sim \\mathcal{N}(0, I) $$ if X X is a control sample, and $$ X \\sim \\mathcal{N}(\\mu, I) $$ if X X is a case sample. Here \\mu \\mu corresponds to a vector which is equal to \\beta_{effect} \\beta_{effect} at the selected differentially expressed genes \\{g_1, \u2026 ,g_m\\} \\{g_1, \u2026 ,g_m\\} and 0 otherwise. Note The dimension of X X is the number of samples times the number of genes. The number of samples is a user-specified quantity, and the number of genes is determined based on the testing context: only genes annotated to the root nodes of the context graph are used.","title":"Selecting Differentially Expressed Genes"},{"location":"manual/#specifying-simulation-parameters","text":"Beyond the gene set, many parameters can be selected. To set simulation parameters, click \u201cSimulation Parameters\u201d to expand simulation options. Use \u201cGene effect size/signal strength\u201d to set \\beta_{effect} \\beta_{effect} . Use \u201cMinimum of samples per case / control\u201d, \u201cMaximum of samples per case / control\u201d and \u201cNumber of linearly spaced sample size regimes\u201d to set number of case and control samples. For instance, if \u201cmin samples\u201d is 10, \u201cmax samples\u201d is 50, and \u201cnum linearly spaced samples\u201d is 10, then sample sizes {10, 20, 30, 40, 50 will be used in the simulation. A user can repeat simulation multiple times for each sample size, default value of \u201cNumber of repetitions per regime\u201d is 10 per sample size. A user can further use \u201cMultiple testing adjustment procedure\u201d to select Bonferroni / BH method to adjust for multiple hypothesis testing. He/she can set desired FDR level in \u201cGO term false discovery rate level\u201d.","title":"Specifying Simulation Parameters"},{"location":"manual/#launching-the-simulation","text":"Finally, to launch the simulation, you will generate a unique job ID. Make sure to store this job ID as it will be used for retrieving the finalized output.","title":"Launching the Simulation"},{"location":"manual/#retrieving-simulation-results","text":"Once the simulation is complete, a user can use our interface to visualize the summary statistics and out customized renderings. The simulation-specific job ID is required to retrieve these results. Successfully loaded simulations should render the context graph that was used for testing, with focus nodes anchored on the (self-contained) non-null GO terms. Following the graph, the next panel on \"Power Analysis Result\" displays all the parameters used for the simulation and the summary statistics including false discovery rate (FDR), power and number of rejected GO terms. As one of our highlighted features, you can also visualize the node-specific power of nodes specified in the focus graph via binder plots by clicking \"View\" next to the \"Binder Plot Summary of the Focus Graph\". Again, this can be adjusted in the previous panel \"Reference Graph for Testing\".","title":"Retrieving Simulation Results"},{"location":"notebook_single_cell/","text":"backup content","title":"Notebook single cell"},{"location":"tutorial/","text":"Focus and Context Graphs This tutorial introduces the concept of focus and context graphs, and how they can render results from existing GO analysis pipelines. It also offers as simple demonstration of how to switch highlighting functions and the focus graph. The data example is based on significant GO terms (within the biological process ontology) identified from a GWAS study. The demonstration is performed within the AEGIS LITE interface, which is available here . Overview of Graph Layouts This tutorial gives an overview of the graph layouts, and some of the interactions on the focus graphs implemented in AEGIS. In particular, the buoyant layout is featured and compared with two other layouts: the root-bound and the leaf-bound layouts. The data example is based on enriched GO terms (within the cellular component ontology) from a ChIP-seq study. The demonstration is performed within the AEGIS LITE interface, which is available here . Interactions to Explore the GO This tutorial demonstrates how to explore the GO without any data inputs. It also demonstrates how to use the search auto-complete, customize some of the visualizations, and select functionally related gene sets (used for a single-cell analysis simulation, for example). The demonstration is performed within the AEGIS LITE interface, which is available here . Power Analysis Workflow This tutorial illustrates the interactive workflow to setup the power analysis with AEGIS. It demonstrates how to customize the context graph to determine the terms to be tested. It also demonstrates how to highlight non-null GO terms based on the signal gene set selection within the interface. The demonstration is performed within the full AEGIS interface, which requires local installation.","title":"Video Tutorials"},{"location":"tutorial/#focus-and-context-graphs","text":"This tutorial introduces the concept of focus and context graphs, and how they can render results from existing GO analysis pipelines. It also offers as simple demonstration of how to switch highlighting functions and the focus graph. The data example is based on significant GO terms (within the biological process ontology) identified from a GWAS study. The demonstration is performed within the AEGIS LITE interface, which is available here .","title":"Focus and Context Graphs"},{"location":"tutorial/#overview-of-graph-layouts","text":"This tutorial gives an overview of the graph layouts, and some of the interactions on the focus graphs implemented in AEGIS. In particular, the buoyant layout is featured and compared with two other layouts: the root-bound and the leaf-bound layouts. The data example is based on enriched GO terms (within the cellular component ontology) from a ChIP-seq study. The demonstration is performed within the AEGIS LITE interface, which is available here .","title":"Overview of Graph Layouts"},{"location":"tutorial/#interactions-to-explore-the-go","text":"This tutorial demonstrates how to explore the GO without any data inputs. It also demonstrates how to use the search auto-complete, customize some of the visualizations, and select functionally related gene sets (used for a single-cell analysis simulation, for example). The demonstration is performed within the AEGIS LITE interface, which is available here .","title":"Interactions to Explore the GO"},{"location":"tutorial/#power-analysis-workflow","text":"This tutorial illustrates the interactive workflow to setup the power analysis with AEGIS. It demonstrates how to customize the context graph to determine the terms to be tested. It also demonstrates how to highlight non-null GO terms based on the signal gene set selection within the interface. The demonstration is performed within the full AEGIS interface, which requires local installation.","title":"Power Analysis Workflow"}]}