{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! This is the documentation webpage for AEGIS ((Augmented Exploration of the GO with Interactive Simulations). AEGIS is an open-source software with an interactive information-retrieval framework that enables an investigator to navigate through the entire Gene Ontology (GO) graph (with tens of thousands of nodes) and focus on fine-grained details without losing the context. It features interpretable visualization of GO terms reported from studies, flexible exploratory analysis of the GO DAG, as well as principled power analysis that is biologically relevant. Getting Started Accompanied with our user manual and video tutorials , there are two options to explore the visualization by AEGIS: the lite version and the full version. The lite version A light weight version of AEGIS is available as a web interface here . It includes the minimal interactive features with some examples for simple demonstrations. The lite version does not require installation and serves as an introduction to our visualization concepts. The full version The full version includes all features, including data upload and power analysis functions. This version is meant to be installed locally and include more customization and computationally intensive processes. The code is open source with api documentation so advanced pipelines can customize it to their needs. Behind the Name According to Greek Mythology , Perseus used Athena\u2019s shield to look at Medusa's reflection without being petrified. This shield that empowered Perseus to defeat Medusa later became the AEGIS. To see the object of interest in a way that is manageable and informative, one cannot directly \u201clook at it,\u201d but appropriate visualization tools are needed. The modern concept of doing something \"under someone's aegis\" means doing something under the protection of a powerful, knowledgeable, or benevolent source. By combining visualization with the rich knowledge in the Gene Ontology, we hope to offer scientists a new tool to discover hidden patterns and uncover the gems in their data. Minerve remettant \u00e0 Pers\u00e9e son bouclier avec lequel il doit combattre La M\u00e9duse by Houasse Ren\u00e9 Antoine ( Image Source ) The Gene Ontology The Gene Ontology (GO) is one of the most popular biological databases. It consists of two continuously evolving elements: (1) a collection of controlled biological terms with semantic hierarchical relationships and (2) annotations that link genes and gene products to specific terms. The GO can be represented as a graph where each node represents a GO term, and each directed link pointing from a parent to a child represents the semantic relationship with two terms. The child term can be related to the parent term via an \u201cis a\u201d, \u201cpart of\u201d or \u201cregulates\u201d relation. There are three root nodes: \u201cbiological process\u201d, \u201cmolecular function\u201d and \u201ccellular component\u201d, and each of their descendants are connected with directed edges in an acyclic fashion. Genes can be simultaneously annotated to different terms, and their annotations propagate upwards in the hierarchy, resulting in the gene sets in the nodes. For more detailed information about the GO, please visit the GO Consortium and the GO Handbook . Contact Us AEGIS is developed and maintained by Junjie (Jason) Zhu in the Sabatti Lab at Stanford University . Both Qian Zhao and Eugene Katsevich have also contributed to the development of this project. You can find the contact information at the webpages or via Github issues. How to Cite Our manuscript is currently under review and instructions will be available soon.","title":"Home"},{"location":"#welcome","text":"This is the documentation webpage for AEGIS ((Augmented Exploration of the GO with Interactive Simulations). AEGIS is an open-source software with an interactive information-retrieval framework that enables an investigator to navigate through the entire Gene Ontology (GO) graph (with tens of thousands of nodes) and focus on fine-grained details without losing the context. It features interpretable visualization of GO terms reported from studies, flexible exploratory analysis of the GO DAG, as well as principled power analysis that is biologically relevant.","title":"Welcome!"},{"location":"#getting-started","text":"Accompanied with our user manual and video tutorials , there are two options to explore the visualization by AEGIS: the lite version and the full version.","title":"Getting Started"},{"location":"#the-lite-version","text":"A light weight version of AEGIS is available as a web interface here . It includes the minimal interactive features with some examples for simple demonstrations. The lite version does not require installation and serves as an introduction to our visualization concepts.","title":"The lite version"},{"location":"#the-full-version","text":"The full version includes all features, including data upload and power analysis functions. This version is meant to be installed locally and include more customization and computationally intensive processes. The code is open source with api documentation so advanced pipelines can customize it to their needs.","title":"The full version"},{"location":"#behind-the-name","text":"According to Greek Mythology , Perseus used Athena\u2019s shield to look at Medusa's reflection without being petrified. This shield that empowered Perseus to defeat Medusa later became the AEGIS. To see the object of interest in a way that is manageable and informative, one cannot directly \u201clook at it,\u201d but appropriate visualization tools are needed. The modern concept of doing something \"under someone's aegis\" means doing something under the protection of a powerful, knowledgeable, or benevolent source. By combining visualization with the rich knowledge in the Gene Ontology, we hope to offer scientists a new tool to discover hidden patterns and uncover the gems in their data. Minerve remettant \u00e0 Pers\u00e9e son bouclier avec lequel il doit combattre La M\u00e9duse by Houasse Ren\u00e9 Antoine ( Image Source )","title":"Behind the Name"},{"location":"#the-gene-ontology","text":"The Gene Ontology (GO) is one of the most popular biological databases. It consists of two continuously evolving elements: (1) a collection of controlled biological terms with semantic hierarchical relationships and (2) annotations that link genes and gene products to specific terms. The GO can be represented as a graph where each node represents a GO term, and each directed link pointing from a parent to a child represents the semantic relationship with two terms. The child term can be related to the parent term via an \u201cis a\u201d, \u201cpart of\u201d or \u201cregulates\u201d relation. There are three root nodes: \u201cbiological process\u201d, \u201cmolecular function\u201d and \u201ccellular component\u201d, and each of their descendants are connected with directed edges in an acyclic fashion. Genes can be simultaneously annotated to different terms, and their annotations propagate upwards in the hierarchy, resulting in the gene sets in the nodes. For more detailed information about the GO, please visit the GO Consortium and the GO Handbook .","title":"The Gene Ontology"},{"location":"#contact-us","text":"AEGIS is developed and maintained by Junjie (Jason) Zhu in the Sabatti Lab at Stanford University . Both Qian Zhao and Eugene Katsevich have also contributed to the development of this project. You can find the contact information at the webpages or via Github issues.","title":"Contact Us"},{"location":"#how-to-cite","text":"Our manuscript is currently under review and instructions will be available soon.","title":"How to Cite"},{"location":"api/","text":"Python Documentation server/dagraph.py class BaseNode(object): \"\"\" Data structure associated with a basic node Attributes: id (int): the global node id cid (int): the context node id children (list of int): the list of child nodes in terms of global node ids parents (list of int): the list of parent nodes in terms of global node ids n_parents (int): the number of parent nodes n_children (int): the number of children nodes n_ancestors (int): the number of ancestral (recursive parent) nodes n_descendents (int): the number of descendent (recursive children) nodes root (bool): whether or not the node is a root leaf (bool): whether or not the node is a leaf \"\"\" class Node(BaseNode): \"\"\" Graph layout node which inherits the BaseNode object. Attributes: name (str): the name annotation of the node, such as \"GO:....\" weight (int): the number of gene annotations depth (int): the longest distance from the roots height (int): the longest distance from the leaves root_distance (int): depth_order: int height_order: int flex: int flex_order: int queried: bool \"\"\" def get_position_info(self): \"\"\" Create a dictionary of depth, height and flex x,y coordinates Args: None Returns: dict: the dictionary with x,y, coordinates under different views \"\"\" class Link(object): \"\"\" Data structure for a link Attributes: source (:obj:Node): the parent node target (:obj:Node): the child node \"\"\" class DAGraph(object): \"\"\" Data structure for a directed cyclic graph Attributes: nodes: a list of Node objects links: a list of Link objects roots: a list of node ids leaves: a list of leaf ids name_index_map: a map from a node name to its index in the `nodes` list \"\"\" def filter_redundant_nodes(self, node_map=None, roots=None): \"\"\" Apply graph refinement to remove redundant nodes Args: node_map: a map of node ids to Node objects (optional) roots: a list of node ids to be the roots (optional) Returns: a map of node ids to Node objects keeping only non-redundant nodes \"\"\" def create_map_to_context_nodes(self, node_context): \"\"\" Create a dictionary for the context nodes given a set of nodes Node objects that can encode the information of the updated height, depth, parents and children in the particular context defined by the nodes under selection. Relationships between nodes are inferred from the original DAG. Args: note_context: a dict of node ids mapping to anything Returns: dict : a map from node ids to new Node objects in the new context list: a list of root nodes in the new context \"\"\" def update_intrinsic_levels(self, metric, node_map=None): \"\"\" Update the hight or depth attributes based on the optional context Args: metric: either \"height\" or \"depth\" node_map: a map from node ids to Node objects (optional) Returns: dict: a map from node ids to Node objects with updated attributes \"\"\" def find_nodes_in_context(self, node_type, node_context, node_map=None): \"\"\" Find either roots or leaves in a node context Args: node_type: either \"root\" of \"leaf\" node_context: a dict or set of node ids node_map: a map from node ids to Node Objects (optional) Returns: list: node ids of the roots or the leaves \"\"\" def find_neighbors(self, node_index, relation, node_map = None, restrict_set= None): \"\"\" Find the neighbors of a node within a context or restricted set Args: node_index: the node id relation: either \"parents\" or \"children\" node_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: a list of (restricted) neighboring node ids \"\"\" def relation_search(self, node_indices, relation, measure = \"level\", node_map = None, restrict_set = None): \"\"\" Perform restricted hierarchical search with a queue Args: node_indices : list of node ids as the anchor for the search relation: either \"parents\" or \"children\" measure: only \"level\" for now node_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: dict: related nodes ids (including the anchors) mapped to measure \"\"\" def create_node_grouping(self, node_list, context_map, restrict_set=None): \"\"\" Given a list of node ids, group their descendants and ancestors into independent subgraphs for better layout. There are always some nodes that are in more than one groups so we want to partition the nodes optimally or greedily Args: node_list: list of node_ids context_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: list: list of set of node ids indicating grouping \"\"\" def compute_focus_flex_level(self, focus_nodes, context_map, gap_break = 5000, block_merge = False): \"\"\" Compute the level of each node using the bubble float algorithm heuristic: larger gap_break yields fewer nodes per level Args: focus_nodes: a set (or list or dict) of node ids context_map: a map from node ids to Node Objects gap_break: the maximum node weight difference between two layers block_merge: (default as False for now) Returns: None (only updates the Node objects in the context map) \"\"\" def create_level_node_map(self, node_levels, node_indices=None): \"\"\" Create a map from level number to the node ids Args: node_levels: a dictionary of node_index to levels (like a context) node_list: a list of nodes to compute the level map for Returns: dict: (level) -> [nidx_1, nidx_2, ...] (ordered list) \"\"\" def compute_node_order(self, node_indices, level_type, context_map): \"\"\" Given node ids and level type, compute its level specific position Uses the the hierarchical ordering heuristic Args: node_indices: a list/dict/set of node ids level_type: \"height\", \"depth\" or \"flex\" context_map: a map from node ids to Node Objects with specified attr Returns: dict: a map from node ids to their order in the level \"\"\" class OrderedContext(): # index all the nodes in a given context cntx_d. # cntx_id is a dictionary mapping full context node id to the node self.sorted_nodes = None self.sorted_index_map = None # fixed_groups: nodes organized in a particular fixed grouping # retrieve the maximum number of levels self.fixed_level_nodes = None def boundary_histogram_search(self, level_breaks): \"\"\" For each level, determine the starting index in that level If the level breaks are [a, b, c], then the counts should be [|{x: x >= a}|, |{x: a > x >= b}|, |{x: b > x >= c}|] NOTE: duplicate boundaries may occur, in this case, this could be due to the fact that there are nodes of the same size in the focus graph. This edge case should be handled before (and possibly after) this funciton is called Parameters ---------- leve_breaks: obj: `list` A descending list of node weights dividers, e.g., [18529, 75, 1] Returns ------- set dict of node indices mapped to their measure \"\"\" def generate_fixed_level_counts(self, lev_t): def bouyant_context_layout(self, focus_node_ids): def format_node_data(self, node): def output_lite_node_info(self): def output_plain_tested_graph(self): class GOStat(): def __init__(self): def set_test_attr_from_dict(self, in_dict): def get_test_attr_as_dict(self): def reverse_list_to_dict(self, in_list, do_sort = True): def setup_simulation_oneway(self, params): def get_simulation_gene_list(self): def get_node_meta_dict(self): def evaluate_rejections(self, rej_list, nonnull_type): def determine_non_null(self, gene_ids): def independent_fisher_tests(self, study_genes, verbose=False): def independent_binomial_tests(self, study_genes, alpha, verbose=False): def independent_global_tests(self, gene_pvalues, method=\"Simes\"): def generate_node_pvals_from_gene_pvals(self, genes, pvals, test=\"simes\", cutoff=None, verbose=False): # the order of the genes should correspond to the p-values # these genes must be entrez ids to match the gene_go_map # returns a list of p-values that correspond to the node ordering # in the Ordered Context def convert_gene_from_to(self, source, target, gene_list): def output_ground_truth_info(self, output_graph=False): class GODAGraph(DAGraph): def __init__(self, cache_dir, name=None, sim_dir=None): DAGraph.__init__(self) # book-keeping attributes self.cache_dir = cache_dir self.sim_dir = sim_dir self.name = name self.go_fname = None # ontology-specific attributes self.ontology = None self.species = None self.version = None self.root = None # gene-related attributes self.go_gene_map = {} self.gene_conversion_map = {} self.go_annotation = {} self.gene_go_map = {} # context and focus graph attributes self.context_graph = OrderedContext() self.context_params = {} self.focus_graph = None self.focus_params = {} # testing attributes self.gohelper = None self.main_statistician = GOStat() def restore_testing_configuration(self, job_id): def load_node_power_matrix(self, output_dir, test, multitest, nonnull_only=False): def output_node_power_matrix(self, job_id, test, multitest): def output_summary_stats(self, job_id, test_method, adjust_method): def generate_node_power_matrix(self, output_dir, test, multitest): def summarize_trial_result(self, dat_dir, reg_i, rep_i): # create summary date frame with fields including fields: # 1. testing_method # 2. adjustment_method # 3. nonnull_type # 3. emperical_fdr # 4. emperical_power # 5. num_rejections # ---------------------- # 6. regime_id # 7. repetition_id # 8. trial_id # ---------------------- def summarize_simulation_results(self, dat_dir): def generate_summary_files(self, data_dir): def launch_simulation_pipeline(self, job_id, cleanup=False): def generate_trial_node_stats(self, data_dir, trial_id): def generate_trial_gene_stats(self, data_dir, trial_id, simulation=True, save_xy=True): def load_full_test_summary(self, data_dir): def load_regime_test_summary(self, data_dir): def load_gene_pvals(self, data_dir, reg_i, rep_i): def load_test_result(self, data_dir, reg_i, rep_i, test, eval_rej=True): def get_node_test_file_info(self, rtype, tmeth, mode=\"Default\", mmeth=None, alpha=None): def get_file_info(self, fd, mode=\"Default\"): def get_file_groups(self, key): def store_test_meta_data(self, data_dir, simulation=True): def output_initialization_data(self): def output_context_summary(self, slow_reachability=False): def output_non_null_go_terms(self, gene_symb_list): def save_result(self, data, fname): def load_result(self, fname): def sample_genes(self, n_genes, go_term, exclude=False, seedn=0): \"\"\" Sample gene sets based on GO term Sample genes that are inclusive or exclusive to a go term. Parameters ---------- n_genes : int Number of genes to sample go_term : str The GO term to focus on exclude: bool, optional To exclude genes from this go-term (default: False: \"include\") seedn: int, optional The random seed to sample the genes (default: 0) Returns ------- None \"\"\" # maps supplied by gohelper def update_with_gene_annotations(self, propagate_to_parents=True, background_gene_set=None): def update_context_indices(self, context): def setup_context_graph(self, rule, target_node_list, min_w=1, max_w=30000, refine_graph=False, store_context=True): \"\"\" Create a context graph based on target nodes and rules Parameters ---------- rule : obj: `str` Rule to build the context: \"waypoint\", \"root\" or \"leaf\" target_node_list: obj: `list` A list of node names (GO:..) that will be the target by the rule. min_w: obj: `int` The minimum number of genes that each node should have max_w: obj: `int` The maximum number of genes that each node should have refine_graph: obj: `bool` Whether or not to remove redundent GO terms Returns ------- set dict of node indices mapped to their measure \"\"\" def select_focus_nodes(self, query_set, context_map, params): def create_node_group_order(self, focus_node_level, groups, level_type, context_map): def create_focus_layout(self, query_set, fnode_set, context_map, params): def setup_focus_graph(self, query_go_ids, ordered_context=None, rule=\"waypoint\", max_descendents=10, force_all_descendents=False, gap_break=5000, grouped=True, ): def get_focus_graph_max_range(self, indexed_focus_nodes): def setup_full_dag(self, ontology, species, version, use_cache=True): \"\"\" Integrates annotaiton information to the GO DAG This steps includes reading the annotation files for a particular root DAG and a particular species, and creating the core structure for context and focus selection, as well as statistical testing. The parameters (root, species and etc.) were determined when the GODAGraph object is created. Parameters ---------- use_cache : :obj:`bool` Whether or not to store/use a cached version of the DAG Returns ------- dict a dictionary mapping from node indices to context Node objects \"\"\" def output_general_info(self): def output_context_info(self, c_graph): def prepare_focus_graph_output(self, query_set, node_set, index_map, context = None): def create_graph_from_root(self, is_a_only=False): def generate_random_pvalues(self): def get_example_gene_set(self, example_i): def get_example_params(self): def example_simulation(self, fixed_size=True, use_cache=False): def plot_full_result(self, data_dir): server/algorithms.py def count_inverions(A): def inverse_cumsum(z): def bubble_float_algo(nodes, node_weights, node_depths, node_parents, node_order=None, gap_break=3, block_merge=False): Javascript Documentation","title":"API Documentation"},{"location":"api/#python-documentation","text":"","title":"Python Documentation"},{"location":"api/#serverdagraphpy","text":"class BaseNode(object): \"\"\" Data structure associated with a basic node Attributes: id (int): the global node id cid (int): the context node id children (list of int): the list of child nodes in terms of global node ids parents (list of int): the list of parent nodes in terms of global node ids n_parents (int): the number of parent nodes n_children (int): the number of children nodes n_ancestors (int): the number of ancestral (recursive parent) nodes n_descendents (int): the number of descendent (recursive children) nodes root (bool): whether or not the node is a root leaf (bool): whether or not the node is a leaf \"\"\" class Node(BaseNode): \"\"\" Graph layout node which inherits the BaseNode object. Attributes: name (str): the name annotation of the node, such as \"GO:....\" weight (int): the number of gene annotations depth (int): the longest distance from the roots height (int): the longest distance from the leaves root_distance (int): depth_order: int height_order: int flex: int flex_order: int queried: bool \"\"\" def get_position_info(self): \"\"\" Create a dictionary of depth, height and flex x,y coordinates Args: None Returns: dict: the dictionary with x,y, coordinates under different views \"\"\" class Link(object): \"\"\" Data structure for a link Attributes: source (:obj:Node): the parent node target (:obj:Node): the child node \"\"\" class DAGraph(object): \"\"\" Data structure for a directed cyclic graph Attributes: nodes: a list of Node objects links: a list of Link objects roots: a list of node ids leaves: a list of leaf ids name_index_map: a map from a node name to its index in the `nodes` list \"\"\" def filter_redundant_nodes(self, node_map=None, roots=None): \"\"\" Apply graph refinement to remove redundant nodes Args: node_map: a map of node ids to Node objects (optional) roots: a list of node ids to be the roots (optional) Returns: a map of node ids to Node objects keeping only non-redundant nodes \"\"\" def create_map_to_context_nodes(self, node_context): \"\"\" Create a dictionary for the context nodes given a set of nodes Node objects that can encode the information of the updated height, depth, parents and children in the particular context defined by the nodes under selection. Relationships between nodes are inferred from the original DAG. Args: note_context: a dict of node ids mapping to anything Returns: dict : a map from node ids to new Node objects in the new context list: a list of root nodes in the new context \"\"\" def update_intrinsic_levels(self, metric, node_map=None): \"\"\" Update the hight or depth attributes based on the optional context Args: metric: either \"height\" or \"depth\" node_map: a map from node ids to Node objects (optional) Returns: dict: a map from node ids to Node objects with updated attributes \"\"\" def find_nodes_in_context(self, node_type, node_context, node_map=None): \"\"\" Find either roots or leaves in a node context Args: node_type: either \"root\" of \"leaf\" node_context: a dict or set of node ids node_map: a map from node ids to Node Objects (optional) Returns: list: node ids of the roots or the leaves \"\"\" def find_neighbors(self, node_index, relation, node_map = None, restrict_set= None): \"\"\" Find the neighbors of a node within a context or restricted set Args: node_index: the node id relation: either \"parents\" or \"children\" node_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: a list of (restricted) neighboring node ids \"\"\" def relation_search(self, node_indices, relation, measure = \"level\", node_map = None, restrict_set = None): \"\"\" Perform restricted hierarchical search with a queue Args: node_indices : list of node ids as the anchor for the search relation: either \"parents\" or \"children\" measure: only \"level\" for now node_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: dict: related nodes ids (including the anchors) mapped to measure \"\"\" def create_node_grouping(self, node_list, context_map, restrict_set=None): \"\"\" Given a list of node ids, group their descendants and ancestors into independent subgraphs for better layout. There are always some nodes that are in more than one groups so we want to partition the nodes optimally or greedily Args: node_list: list of node_ids context_map: a map from node ids to Node Objects (optional) restrict_set: a dict or set of node ids to restrict search Returns: list: list of set of node ids indicating grouping \"\"\" def compute_focus_flex_level(self, focus_nodes, context_map, gap_break = 5000, block_merge = False): \"\"\" Compute the level of each node using the bubble float algorithm heuristic: larger gap_break yields fewer nodes per level Args: focus_nodes: a set (or list or dict) of node ids context_map: a map from node ids to Node Objects gap_break: the maximum node weight difference between two layers block_merge: (default as False for now) Returns: None (only updates the Node objects in the context map) \"\"\" def create_level_node_map(self, node_levels, node_indices=None): \"\"\" Create a map from level number to the node ids Args: node_levels: a dictionary of node_index to levels (like a context) node_list: a list of nodes to compute the level map for Returns: dict: (level) -> [nidx_1, nidx_2, ...] (ordered list) \"\"\" def compute_node_order(self, node_indices, level_type, context_map): \"\"\" Given node ids and level type, compute its level specific position Uses the the hierarchical ordering heuristic Args: node_indices: a list/dict/set of node ids level_type: \"height\", \"depth\" or \"flex\" context_map: a map from node ids to Node Objects with specified attr Returns: dict: a map from node ids to their order in the level \"\"\" class OrderedContext(): # index all the nodes in a given context cntx_d. # cntx_id is a dictionary mapping full context node id to the node self.sorted_nodes = None self.sorted_index_map = None # fixed_groups: nodes organized in a particular fixed grouping # retrieve the maximum number of levels self.fixed_level_nodes = None def boundary_histogram_search(self, level_breaks): \"\"\" For each level, determine the starting index in that level If the level breaks are [a, b, c], then the counts should be [|{x: x >= a}|, |{x: a > x >= b}|, |{x: b > x >= c}|] NOTE: duplicate boundaries may occur, in this case, this could be due to the fact that there are nodes of the same size in the focus graph. This edge case should be handled before (and possibly after) this funciton is called Parameters ---------- leve_breaks: obj: `list` A descending list of node weights dividers, e.g., [18529, 75, 1] Returns ------- set dict of node indices mapped to their measure \"\"\" def generate_fixed_level_counts(self, lev_t): def bouyant_context_layout(self, focus_node_ids): def format_node_data(self, node): def output_lite_node_info(self): def output_plain_tested_graph(self): class GOStat(): def __init__(self): def set_test_attr_from_dict(self, in_dict): def get_test_attr_as_dict(self): def reverse_list_to_dict(self, in_list, do_sort = True): def setup_simulation_oneway(self, params): def get_simulation_gene_list(self): def get_node_meta_dict(self): def evaluate_rejections(self, rej_list, nonnull_type): def determine_non_null(self, gene_ids): def independent_fisher_tests(self, study_genes, verbose=False): def independent_binomial_tests(self, study_genes, alpha, verbose=False): def independent_global_tests(self, gene_pvalues, method=\"Simes\"): def generate_node_pvals_from_gene_pvals(self, genes, pvals, test=\"simes\", cutoff=None, verbose=False): # the order of the genes should correspond to the p-values # these genes must be entrez ids to match the gene_go_map # returns a list of p-values that correspond to the node ordering # in the Ordered Context def convert_gene_from_to(self, source, target, gene_list): def output_ground_truth_info(self, output_graph=False): class GODAGraph(DAGraph): def __init__(self, cache_dir, name=None, sim_dir=None): DAGraph.__init__(self) # book-keeping attributes self.cache_dir = cache_dir self.sim_dir = sim_dir self.name = name self.go_fname = None # ontology-specific attributes self.ontology = None self.species = None self.version = None self.root = None # gene-related attributes self.go_gene_map = {} self.gene_conversion_map = {} self.go_annotation = {} self.gene_go_map = {} # context and focus graph attributes self.context_graph = OrderedContext() self.context_params = {} self.focus_graph = None self.focus_params = {} # testing attributes self.gohelper = None self.main_statistician = GOStat() def restore_testing_configuration(self, job_id): def load_node_power_matrix(self, output_dir, test, multitest, nonnull_only=False): def output_node_power_matrix(self, job_id, test, multitest): def output_summary_stats(self, job_id, test_method, adjust_method): def generate_node_power_matrix(self, output_dir, test, multitest): def summarize_trial_result(self, dat_dir, reg_i, rep_i): # create summary date frame with fields including fields: # 1. testing_method # 2. adjustment_method # 3. nonnull_type # 3. emperical_fdr # 4. emperical_power # 5. num_rejections # ---------------------- # 6. regime_id # 7. repetition_id # 8. trial_id # ---------------------- def summarize_simulation_results(self, dat_dir): def generate_summary_files(self, data_dir): def launch_simulation_pipeline(self, job_id, cleanup=False): def generate_trial_node_stats(self, data_dir, trial_id): def generate_trial_gene_stats(self, data_dir, trial_id, simulation=True, save_xy=True): def load_full_test_summary(self, data_dir): def load_regime_test_summary(self, data_dir): def load_gene_pvals(self, data_dir, reg_i, rep_i): def load_test_result(self, data_dir, reg_i, rep_i, test, eval_rej=True): def get_node_test_file_info(self, rtype, tmeth, mode=\"Default\", mmeth=None, alpha=None): def get_file_info(self, fd, mode=\"Default\"): def get_file_groups(self, key): def store_test_meta_data(self, data_dir, simulation=True): def output_initialization_data(self): def output_context_summary(self, slow_reachability=False): def output_non_null_go_terms(self, gene_symb_list): def save_result(self, data, fname): def load_result(self, fname): def sample_genes(self, n_genes, go_term, exclude=False, seedn=0): \"\"\" Sample gene sets based on GO term Sample genes that are inclusive or exclusive to a go term. Parameters ---------- n_genes : int Number of genes to sample go_term : str The GO term to focus on exclude: bool, optional To exclude genes from this go-term (default: False: \"include\") seedn: int, optional The random seed to sample the genes (default: 0) Returns ------- None \"\"\" # maps supplied by gohelper def update_with_gene_annotations(self, propagate_to_parents=True, background_gene_set=None): def update_context_indices(self, context): def setup_context_graph(self, rule, target_node_list, min_w=1, max_w=30000, refine_graph=False, store_context=True): \"\"\" Create a context graph based on target nodes and rules Parameters ---------- rule : obj: `str` Rule to build the context: \"waypoint\", \"root\" or \"leaf\" target_node_list: obj: `list` A list of node names (GO:..) that will be the target by the rule. min_w: obj: `int` The minimum number of genes that each node should have max_w: obj: `int` The maximum number of genes that each node should have refine_graph: obj: `bool` Whether or not to remove redundent GO terms Returns ------- set dict of node indices mapped to their measure \"\"\" def select_focus_nodes(self, query_set, context_map, params): def create_node_group_order(self, focus_node_level, groups, level_type, context_map): def create_focus_layout(self, query_set, fnode_set, context_map, params): def setup_focus_graph(self, query_go_ids, ordered_context=None, rule=\"waypoint\", max_descendents=10, force_all_descendents=False, gap_break=5000, grouped=True, ): def get_focus_graph_max_range(self, indexed_focus_nodes): def setup_full_dag(self, ontology, species, version, use_cache=True): \"\"\" Integrates annotaiton information to the GO DAG This steps includes reading the annotation files for a particular root DAG and a particular species, and creating the core structure for context and focus selection, as well as statistical testing. The parameters (root, species and etc.) were determined when the GODAGraph object is created. Parameters ---------- use_cache : :obj:`bool` Whether or not to store/use a cached version of the DAG Returns ------- dict a dictionary mapping from node indices to context Node objects \"\"\" def output_general_info(self): def output_context_info(self, c_graph): def prepare_focus_graph_output(self, query_set, node_set, index_map, context = None): def create_graph_from_root(self, is_a_only=False): def generate_random_pvalues(self): def get_example_gene_set(self, example_i): def get_example_params(self): def example_simulation(self, fixed_size=True, use_cache=False): def plot_full_result(self, data_dir):","title":"server/dagraph.py"},{"location":"api/#javascript-documentation","text":"","title":"Javascript Documentation"},{"location":"install/","text":"AEGIS is an open-source software, and the back-end and front-end implementations in Python and Javscript are available under the MIT License. The following instructions are used to install the full version of AEGIs, which includes all of its functionalities including power calculation. Install Dependencies Prerequisites : Python3 (required), virtualenv or other package managements (recommended). The code is available on github, so you can directly clone the repository to your local: git clone git@github.com:junjiezhujason/aegis.git Installing of dependencies only requires one line: pip3 install -r requirements.txt AEGIS also requires specification of a folder: ${LOCALPATH} to store the cached files. This is mainly for version control and speed performance. For most of the analyses (excluding simulation outputs), the files will typically require no more than 250M of disk space. Note : If this is the first time that you are running AEGIS locally, Internet connection will be required to download data (or our cached files below) from the online databases. Download Caches (Optional) You can manually pre-propagate some local files in ${LOCALPATH} to reduce setup time. Once the cache is stored, most features of AEGIS can be performed locally without Internet connection for ontology or data download. Simply download the light cache files of (version-controlled) species/ontologies here and unpack to the directory ${LOCALPATH} , e.g., local_${VERSION}.tar.gz Make sure to expand the files in the ${LOCALPATH} so that the folder includes them in the following format: ${LOCALPATH}/local/godag_*.pkl Here is an example of the command line workflow: cd ${LOCALPATH} wget http://stanford.edu/~jjzhu/fileshare/aegis/local_20180710.tar.gz tar -xvzf local_20180710.tar.gz The local directory should have the following structure, for example: ${LOCALPATH}/local/godag-biological_process-human-20180719.pkl ${LOCALPATH}/local/godag-biological_process-mouse-20180719.pkl ${LOCALPATH}/local/godag-cellular_component-human-20180719.pkl ${LOCALPATH}/local/godag-cellular_component-mouse-20180719.pkl ${LOCALPATH}/local/godag-molecular_function-human-20180719.pkl ${LOCALPATH}/local/godag-molecular_function-mouse-20180719.pkl Here 20180719 represents the version number of the ontology paired with the annotation. It is highly useful for reproducing any results from the GO as well as AEGIS. Note : If you skip this step, the latest version of the GO and annotation files will be downloaded, and the total setup time will take longer. Launch the Local Server To launch the server, run: python3 main.py --port 5000 --folder ${LOCALPATH} Note : both the port number and the local path options are required. If this is your first time running AEGIS and you did not download our cached files, AEGIS will automatically download the latest gene and go annotations. This may take a while, and the following extra files will be automatically generated inside the local directory: ${LOCALPATH}/local/gene2go ${LOCALPATH}/local/go-basic.obo ${LOCALPATH}/local/geneid2sym_human.json ${LOCALPATH}/local/geneid2sym_mouse.json and later, the program will also generate the cached files ${LOCALPATH}/local/godag-*-*-*.pkl The version number will be based on the date the files are downloaded and when the .pkl file is created. By default, AEGIS will continue this version if the same ${LOCALPATH} is specified. To update the version, simply create a new local path to repeat the analysis above. Finally, open your local browser with http://localhost:5000/","title":"Installation"},{"location":"install/#install-dependencies","text":"Prerequisites : Python3 (required), virtualenv or other package managements (recommended). The code is available on github, so you can directly clone the repository to your local: git clone git@github.com:junjiezhujason/aegis.git Installing of dependencies only requires one line: pip3 install -r requirements.txt AEGIS also requires specification of a folder: ${LOCALPATH} to store the cached files. This is mainly for version control and speed performance. For most of the analyses (excluding simulation outputs), the files will typically require no more than 250M of disk space. Note : If this is the first time that you are running AEGIS locally, Internet connection will be required to download data (or our cached files below) from the online databases.","title":"Install Dependencies"},{"location":"install/#download-caches-optional","text":"You can manually pre-propagate some local files in ${LOCALPATH} to reduce setup time. Once the cache is stored, most features of AEGIS can be performed locally without Internet connection for ontology or data download. Simply download the light cache files of (version-controlled) species/ontologies here and unpack to the directory ${LOCALPATH} , e.g., local_${VERSION}.tar.gz Make sure to expand the files in the ${LOCALPATH} so that the folder includes them in the following format: ${LOCALPATH}/local/godag_*.pkl Here is an example of the command line workflow: cd ${LOCALPATH} wget http://stanford.edu/~jjzhu/fileshare/aegis/local_20180710.tar.gz tar -xvzf local_20180710.tar.gz The local directory should have the following structure, for example: ${LOCALPATH}/local/godag-biological_process-human-20180719.pkl ${LOCALPATH}/local/godag-biological_process-mouse-20180719.pkl ${LOCALPATH}/local/godag-cellular_component-human-20180719.pkl ${LOCALPATH}/local/godag-cellular_component-mouse-20180719.pkl ${LOCALPATH}/local/godag-molecular_function-human-20180719.pkl ${LOCALPATH}/local/godag-molecular_function-mouse-20180719.pkl Here 20180719 represents the version number of the ontology paired with the annotation. It is highly useful for reproducing any results from the GO as well as AEGIS. Note : If you skip this step, the latest version of the GO and annotation files will be downloaded, and the total setup time will take longer.","title":"Download Caches (Optional)"},{"location":"install/#launch-the-local-server","text":"To launch the server, run: python3 main.py --port 5000 --folder ${LOCALPATH} Note : both the port number and the local path options are required. If this is your first time running AEGIS and you did not download our cached files, AEGIS will automatically download the latest gene and go annotations. This may take a while, and the following extra files will be automatically generated inside the local directory: ${LOCALPATH}/local/gene2go ${LOCALPATH}/local/go-basic.obo ${LOCALPATH}/local/geneid2sym_human.json ${LOCALPATH}/local/geneid2sym_mouse.json and later, the program will also generate the cached files ${LOCALPATH}/local/godag-*-*-*.pkl The version number will be based on the date the files are downloaded and when the .pkl file is created. By default, AEGIS will continue this version if the same ${LOCALPATH} is specified. To update the version, simply create a new local path to repeat the analysis above. Finally, open your local browser with http://localhost:5000/","title":"Launch the Local Server"},{"location":"manual/","text":"Under construction Visualization Concepts GO Term Data Input (Optional) Main Navigation Features Visualization Customization Gene Set Selection (Optional) Power Analysis and Simulation","title":"Basic Manual"},{"location":"manual/#visualization-concepts","text":"","title":"Visualization Concepts"},{"location":"manual/#go-term-data-input-optional","text":"","title":"GO Term Data Input (Optional)"},{"location":"manual/#main-navigation-features","text":"","title":"Main Navigation Features"},{"location":"manual/#visualization-customization","text":"","title":"Visualization Customization"},{"location":"manual/#gene-set-selection-optional","text":"","title":"Gene Set Selection (Optional)"},{"location":"manual/#power-analysis-and-simulation","text":"","title":"Power Analysis and Simulation"},{"location":"notebook_single_cell/","text":"backup content","title":"Notebook single cell"},{"location":"tutorial/","text":"Focus and Context Graphs This tutorial introduces the concept of focus and context graphs, and how they can render results from existing GO analysis pipelines. It also offers as simple demonstration of how to switch highlighting functions and the focus graph. The data example is based on significant GO terms (within the biological process ontology) identified from a GWAS study. The demonstration is performed within the AEGIS LITE interface, which is available here . Overview of Graph Layouts This tutorial gives an overview of the graph layouts, and some of the interactions on the focus graphs implemented in AEGIS. In particular, the buoyant layout is featured and compared with two other layouts: the root-bound and the leaf-bound layouts. The data example is based on enriched GO terms (within the cellular component ontology) from a ChIP-seq study. The demonstration is performed within the AEGIS LITE interface, which is available here . Interactions to Explore the GO This tutorial demonstrates how to explore the GO without any data inputs. It also demonstrates how to use the search auto-complete, customize some of the visualizations, and select functionally related gene sets (used for a single-cell analysis simulation, for example). The demonstration is performed within the AEGIS LITE interface, which is available here . Power Analysis Workflow This tutorial illustrates the interactive workflow to setup the power analysis with AEGIS. It demonstrates how to customize the context graph to determine the terms to be tested. It also demonstrates how to highlight non-null GO terms based on the signal gene set selection within the interface. The demonstration is performed within the full AEGIS interface, which requires local installation.","title":"Video Tutorials"},{"location":"tutorial/#focus-and-context-graphs","text":"This tutorial introduces the concept of focus and context graphs, and how they can render results from existing GO analysis pipelines. It also offers as simple demonstration of how to switch highlighting functions and the focus graph. The data example is based on significant GO terms (within the biological process ontology) identified from a GWAS study. The demonstration is performed within the AEGIS LITE interface, which is available here .","title":"Focus and Context Graphs"},{"location":"tutorial/#overview-of-graph-layouts","text":"This tutorial gives an overview of the graph layouts, and some of the interactions on the focus graphs implemented in AEGIS. In particular, the buoyant layout is featured and compared with two other layouts: the root-bound and the leaf-bound layouts. The data example is based on enriched GO terms (within the cellular component ontology) from a ChIP-seq study. The demonstration is performed within the AEGIS LITE interface, which is available here .","title":"Overview of Graph Layouts"},{"location":"tutorial/#interactions-to-explore-the-go","text":"This tutorial demonstrates how to explore the GO without any data inputs. It also demonstrates how to use the search auto-complete, customize some of the visualizations, and select functionally related gene sets (used for a single-cell analysis simulation, for example). The demonstration is performed within the AEGIS LITE interface, which is available here .","title":"Interactions to Explore the GO"},{"location":"tutorial/#power-analysis-workflow","text":"This tutorial illustrates the interactive workflow to setup the power analysis with AEGIS. It demonstrates how to customize the context graph to determine the terms to be tested. It also demonstrates how to highlight non-null GO terms based on the signal gene set selection within the interface. The demonstration is performed within the full AEGIS interface, which requires local installation.","title":"Power Analysis Workflow"}]}